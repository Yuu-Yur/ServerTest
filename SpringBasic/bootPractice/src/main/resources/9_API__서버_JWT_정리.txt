자바 웹개발 워크북 9

API 서버와 JWT

최근 웹 개발 방식의 가장 큰 변화는 
서버와 클라이언트 개발의 분리에서 시작합니다. 

기존과 달리 서버는 클라우드 환경에서 필요한 데이터만 제공하고, 
클라이언트는 브라우저나 앱과 같이 다양하게 구현되는 방식입니다. 

브라우저는 리액트나 Vuejs와 같은 자바스크립트 라이브러리를 이용하고, 
Ajax를 이용해서 REST 방식으로 API를 호출하고 
결과를 받아서 처리하게 됩니다. 

이를 위해서는 기존 방식과 다른 접근이 필요하게 되는데 
예제를 통해서 이러한 구조와 흐름을 알아보도록 합니다


___

9.1 JWT 인증

화면 없이 Ajax와 JSON을 이용해서 데이터를 주고받는 구조에서는 
HttpSession이나 쿠키를 이용하는 기존의 인증 방식에 제한받게 됩니다. 

이를 해결하기 위해서 인증받은 사용자들은 
특정한 문자열(토큰)을 이용하게 되는데 
이때 많이 사용하는 것이 JWT(JSON Web Token)입니다.

이 절부터는 API 서버를 구성하기 위해 
별도의 프로젝트를 만들고 
스프링 시큐리티로 이를 처리해 보도록 합니다.


API 서버

API 서버는 쉽게 말해서 '필요한 데이터만 제공하는 서버'를 의미합니다. 
API 서버는 화면을 제공하는 것이 아니라 
필요한 데이터를 호출하고 결과를 반환 받는 방식으로 동작합니다. 
따라서 API 서버에서 가장 먼저 눈에 띄는 
특징은 화면을 제공하지 않는다'가 됩니다.

Web
App    <--JSON--> Server
etc*


브라우저에 필요한 화면의 모든 코드(HTML)를 
서버에서 만들어 전송하는 방식을 
서버 사이드 렌더링(Server Side Rendering 이하 SSR)이라고 하는데 
JSP와 Thymeleat가 이에 해당합니다.


Browser       <-------완성된 코드<-------Server
코드를 출력하는 
뷰어(viewer)역할 



___

API 서버는 화면 구성은 별도의 클라이언트 프로그램에서 처리하고 
서버에서는 순수한 데이터만을 전송하게 됩니다. 

이러한 구성을 '클라이언트 사이드 렌더링
(Client Side Ren-dering 이하 CSR)이라고 합니다.


Browser       <-------순수한 데이터<-------Server
재료를 가공해서 
완성품을 만드는
프로그램


CSR 방식은 클라이언트에서 데이터를 가공해서 화면에 보여주기 때문에 
데이터를 어떻게 구성해서 주고받을 것인지가 중요한데, 
주로 JSON/XML, 포맷으로 데이터를 구성하고 
호출 방식은 REST 방식을 이용하는 경우가 많습니다.

API 서버는 화면을 구성하지 않는다는 특징 외에도 
'무상태(stateless)'라는 특징도 있습니다. 

이것은 사실 API 서버의 특징이라기보다는 
REST나 HTTP의 특징이지만 
개발에 약간의 차이가 있기 때문에 주의가 필요합니다.

전통적인 SSR 방식의 서비스는 쿠키와 세션을 이용해서 
서버에서 사용자 정보를 추적할 수 있었습니다. 

쿠키의 경우 쿠키를 발행한 서버를 호출할 때에만 전달되는 방식이고, 
세션의 경우 서버 내부에서 JSESSIONID와 같은 이름의 쿠키를 통해서 
사용자 정보를 보관하고 처리할 수가 있습니다.

반면 API 서버는 쿠키를 이용해서 데이터를 교환하는 방식이 아닙니다. 
API 서버는 단순히 '요청(request)과 '응답(response)'에서 
발생한 부수적인 결과를 유지하지 않습니다. 

예를 들어 
API 서버는 JSESSIONID 이름의 쿠키를 발행하거나 
개발자가 직접 쿠키를 생성하지는 않습니다. 

API 서버는 순수하게 데이터를 요청하고 응답받는 방식으로 구성됩니다.


토큰 기반의 인증

API 서버가 단순히 데이터만을 주고받을 때 외부에서 
누구나 호출하는 URI를 알게 되면 문제가 생기게 됩니다. 

당연히 API 서버에는 다양한 방법으로 특정한 사용자나 
프로그램에서만 API 서버를 호출할 수 있도록 
제한하는 방법이 필요합니다.

___

초창기 API 서버는 주로 API를 호출하는 프로그램의 
IP 주소를 이용했습니다. 

API 서버를 호출하는 쪽의 IP와 API 서버 내에 보관된 IP를 
비교해서 허용된 IP에서만 API 서버에서 결과를 만들어주는 방식입니다. 

IP와 더불어서 정해진 키(key) 값을 같이 
사용하는 것이 일반적인 형태입니다.

예제에서 

사용할 방식은 토큰(token)을 이용하는 방식입니다. 
토큰은 일종의 '표식'과 같은 역할을 하는 데이터입니다. 
현실적으로 토큰은 서버와 클라이언트가 주고받는 '문자열'에 
불과한데 API 서버를 이용하고자 하는 사람들은 API 서버에서 
토큰을 받아 보관하고 호출할 때 
자신이 가지고 있는 토큰을 같이 전달해서 API 서버에서 
이를 확인하는 방식입니다. 
이런 방식은 실생활에서 흔히 사용되는 
입장권(ticket)과 유사한 개념입니다. 

API 서버에서는 입장권을 발행해 주고 
클라이언트는 입장권을 가지고 방문하게하는 원리입니다.


Browser      <-------서버에서 발행해준 입장권<-------Server
사용자는 
서버에 요청할때 
입장권을 제시


• Access Token / Refresh Token의 의미
입장권에 해당하는 토큰(token)을 API 서버에서는 
'Access Token'이라고 합니다. 

Access Token은 말그대로 '특정한 자원에 접근할 권한이 있는지를 검사'
하기 위한 용도입니다. 
Access Token은 입장권과 같기 때문에 외부에서 API 서버를 호출할 때 
Access Token을 함께 전달하면 이를 이용해서 검증하고 
그 결과에 따라서 요청을 처리합니다.

만일 Access Token을 악의적인 사용자에게 탈취당한다면 
문제가 발생합니다. 

따라서 Access Token을 이용할 때는 
최대한 유효 시간을 짧게 지정하고 
사용자에게는 Access Token 을 새로 발급받을 수 있는 
Refresh Token이라는 것을 같이 생성해 주어서 필요할 때 
다시 Access Token을 발급 받을 수 있도록 구성합니다

(Refresh Token이 반드시 필수라고 할 수 는 없습니다. 
다시 Access Token을 발급 받기만 한다면 
다른 방법도 고려할 수 있습니다).

Access Token, Refresh Token을 이용하는 
정상적인 시나리오는 다음과 같습니다.

___

Client Program               API Server
               ------------>1번
			   <------------
Access Token
Refresh Token		
					Access Token		
			   ------------>2번
JSON Data	   <------------ 3번


1번 
사용자는 API 서버로부터 Access Token과 Refresh Token을 받습니다. 
예를 들어 
Access Token의 유효기간은 1일, 
Refresh Token의 유효 기간은 10일이라고 가정합니다.

2번
사용자가 특정한 작업을 하기 위해서 Access Token을 전달합니다.

3번
서버는 우선 Acess Token을 검사하고 해당 토큰이 유효한지 
확인해서 작업을 처리합니다. 
예를 들어 
Access Token을 발행 받은 당일이라면 
문제없이 작업이 처리될 수 있습니다.

토큰(token) 방식에서 걸림돌이 되는 것은 
실제로는 단순한 문자열인 토큰의 보안 문제입니다. 
누군가 토큰을 탈취해서 서버에 요청하게 된다면 
서버에서 정상적인 사용자로 간주하기 때문입니다. 

따라서 Access Token을 작성할 때는 
기본적으로 암호화나 인코딩 처리가 필요하고
Access Token 내부에 유효 시간을 지정해서 
짧은 시간 동안만 토큰을 사용할 수 있도록 처리해야 합니다.

Access Token이 만료되는 상황을 생각해 봅니다.


Client Program               API Server
               ------->Access Token 1번
			   <------------        Expired AccessToken
Access Token Refresh Token		
					Access Token		
			   ------------>2번     Generate New Tokens
New Access Token <------------
New Refresh Token	 

1번
사용자가 Access Token을 전달합니다. 
API 서버에서는 Access Token을 검증하는데 
이 과정에서'만료된(expired)' 토큰임을 확인하고 
사용자에게 만료된 토큰임을 알려줍니다.

2번
사용자는 자신이 가지고있는 Refresh Token을 전송해서 
새로운 Access Token을 요구합니다. 

API 서버에서는 Refresh Token에 문제가 없다면 
새로운 Access Token을 생성해서 전달합니다. 
이 과정에서 Refresh Token이 거의 만료된 상황이라면 
새로운 Refresh Token을 같이 전송할 수도 있습니다.

토큰을 이용하는 방식은 네트워크로 데이터를 주고받기 때문에 
항상 보안 문제가 있습니다. 

Access Token과 마찬가지로 Refresh Token 역시 탈취될 때는 
문제가 될 수 있습니다. 

만일 Acess Token과 Refresh Token 모두를 탈취당하면 
API 서버에서는 사용자를 구분할 수 없는 문제가 생깁니다
(이를 해결하기 위해 비밀키를 지정할 수도 있겠지만, 
비밀키가 탈취당 하면 같은 문제가 발생하므로 
근본적인 해결책은 아닙니다). 

그나마 현실적인 해결책은 Refresh Token으로 
새로운 Access Token이 생성되는 것을 
원래의 사용자가 알 수 있도록 하는 것입니다.

Tip
예를 들어 
구글이나 네이버 로그인을 평소와 다른 장소에서 하면 
본인 스스로 한 것이 맞는지 확인 하는 메일이나 
핸드폰 알림 등이 발송되는 것을 본 적이 있을 것입니다. 

Access Token과 Refresh Token 역시 이처럼 원래의 
사용자에게 활동 여부를 알려주거나 특정한 IP에서만 
사용할 수 있도록 하는 방법 등을 사용해서 
조금 더 안전하게 만들 수 있습니다.

Refresh Token은 유효 시간을 조금 길게 주는데 
Access Token이 짧을수록 Refresh Token이 자주 사용되게 됩니다. 

하지만 Refresh Token에도 유효 시간이 있으므로 
오랜 시간 동안 사용하지 않는다면 언젠가는 만료됩니다. 

따라서 새로운 Access Token을 생성할 때 
Refresh Token의 유효 시간이 얼마 남지 않았다면 
Refresh Token도 같이 생성해서 전달하는 방식이 많이 사용됩니다.

__
인증을 위한 프로젝트 구성

예제 프로젝트를 작성하기 전에 앞에서 설명한 구조를 
어떻게 구현할 것인지 간단히 살펴 보도록 합니다. 
기존 프로젝트와 달라지는 점들은 다음과 같습니다.

___

1 스프링 시큐리티의 필터를 이용해서 토큰들을 검사 - 
서블릿의 필터(Filter)와 유사하지만 스프링의 
빈들을 사용할 수 있다는 장점이 있습니다.
  
2 화면 구성이 필요하지 않으므로 Thymeleaf를 사용하지 않음

3 자동으로 세션/쿠키를 생성하지 않음(무상태로 처리)

4 JWT 문자열을 생성해서 토큰으로 사용


예제 프로젝트 생성

예제 프로젝트에서 구현해야 하는 내용은 크게 다음과 같습니다.

1 Access Token과 Refresh Token의 생성 처리
2 Access Token이 만료되었을 때의 처리
3 Refresh Token의 검사와 만료가 얼마 남지않은 
Refresh Token의 갱신, 새로운 Access Token의 생성

새롭게 생성하는 프로젝트의 이름은 api5012'로 지정하고 
Gradle을 이용하도록 구성합니다.

com.busanit501
17
jar 

3.4.1

새로운 프로젝트를 구성할 때 Thymeleaf는 필요하지 않으므로 제외하고 
프로젝트를 구성합니다.

Spring Boot: 3.4.1
Spring Boot DevTools
Lombok
Spring Web
Spring Security
Spring Data JPA
MariaDB Driver

생성된 프로젝트가 실행 중에 자동 갱신될 수 있도록 설정하고 
데이터베이스를 지정합니다.


build.gradle의 dependencies에는 Swagger-UI와 
Model-Mapper 라이브러리를 추가하고 
테스트 환경에 Lombok을 활성하하는 설정도 추가합니다.

dependencies {
...생략. . .
 testCompileOnly 'org.projectlombok:lombok'
    testAnnotationProcessor 'org.projectlombok:lombok'

    implementation 'org.modelmapper:modelmapper:3.1.0'

   	//교체
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.3'

}

application.properties에는 데이터베이스 관련 정보와 
Spring Data JPA관련 설정, 로그 설정 등을 추가합니다.

spring.application.name=api5012
# MariaDB Configuration
spring.datasource.url=jdbc:mariadb://localhost:3306/webdb
spring.datasource.username=webuser
spring.datasource.password=webuser
#spring.datasource.driver-class-name=org.mariadb.jdbc.Driver

# Hibernate settings for MariaDB
#spring.jpa.database-platform=org.hibernate.dialect.MariaDBDialect
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.show-sql=true

#logging
logging.level.org.springframework=info
logging.level.com.busanit501=debug
logging.level.org.springframework.security=debug


• ModelMapper/Swagger UlSecurity 설정 

프로젝트에서는 이전 예제에서 다루었던 여러 설정이 필요하므로 
config 패키지를 추가해서 필요한 설정 클래스들을 작성하도록 합니다.

추가하려는 클래스는 이전 예제에서 다루었던 
CustomSecurityConfig, 
RootConfig, 
CustomServletConfig,
SwaggerConfig 입니다
(기존 코드를 추가하기 때문에 
CustomSecurityConfig 클래스는 에러가 발생하게 됩니다).

Custom SecurityConfg 클래스에서는 
①CSRF 토큰의 비활성화와 ②세션을 사용하지 않을 것을 지정합니다.


package com.busanit501.api5012.config;

import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;

@Log4j2
@Configuration
// 어노테이션을 이용해서, 특정 권한 있는 페이지 접근시, 구분가능.
//@EnableGlobalMethodSecurity(prePostEnabled = true)
// 위 어노테이션 지원중단, 아래 어노테이션 으로 교체, 기본으로 prePostEnabled = true ,
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class CustomSecurityConfig {

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        log.info("시큐리티 동작 확인 ====webSecurityCustomizer======================");
        return (web) ->
                web.ignoring()
                        .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        log.info("===========config=================");

        http.csrf(httpSecurityCsrfConfigurer -> httpSecurityCsrfConfigurer.disable());
        http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        return http.build();
    }


}



RootConfig에는 ModelMapper 설정만을 추가합니다.

package com.busanit501.api5012.config;

import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@Configuration
@EnableJpaAuditing
public class RootConfig {

    @Bean
    public ModelMapper getMapper() {
        ModelMapper modelMapper = new ModelMapper();
        modelMapper.getConfiguration()
                .setFieldMatchingEnabled(true)
                .setFieldAccessLevel(org.modelmapper.config.Configuration.AccessLevel.PRIVATE)
                .setMatchingStrategy(MatchingStrategies.LOOSE);

        return modelMapper;
    }
}



CustomServletConfig에 별다른 내용은 없지만 
나중에 파라미터 타입의 변환을 추가할 수 있도록 
클래스를 생성합니다
(작성하는 프로젝트의 실행은 이 단계까지 설정되어야 
에러가 발생하지 않습니다).

package com.busanit501.api5012.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@EnableWebMvc
public class CustomServletConfig implements WebMvcConfigurer {

}


Swagger Config는 @RestController 어노테이션이 있는 
컨트롤러들에 대해서 API 문서를 생성하도록 작성함.

package com.busanit501.api5012.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.bind.annotation.RestController;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import io.swagger.v3.oas.models.info.Info;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI openAPI() {

        // Security 설정 추가
        SecurityScheme securityScheme = new SecurityScheme()
                .type(SecurityScheme.Type.HTTP)
                .scheme("bearer")
                .bearerFormat("JWT")
                .name("Authorization");

        return new OpenAPI()
                .info(new Info()
                        .title("레스트 API 테스트")
                        .description("Rest 활용해서 댓글도 구현해보기")
                        .version("1.0.0")
                );
                //추가
                //.addSecurityItem(new SecurityRequirement().addList("Authorization"))
                //.schemaRequirement("Authorization", securityScheme);
    }

}


•Swagger UI 설정 확인

추가된 설정들이 문제없이 동작하는지 확인하기 위해서 
간단한 컨트롤러를 구성하고 이를 확인합니다.
프로젝트에 controller 패키지를 작성하고 
SampleController를 추가합니다.

SampleController는 단순하게 문자열의 배열을 반환 하는 
기능을 다음과 같이 작성합니다.

package com.busanit501.api5012.controller;

import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Arrays;
import java.util.List;

@RestController
@RequestMapping("/api/sample") // API 엔드포인트 기본 경로 설정
public class SampleController {

    @Tag(name = "샘플 레스트",
            description = "AAA, BBB, CCC 출력 테스트")
    @GetMapping("/doA") // GET 요청 처리 경로
    public List<String> doA() {
        // 문자열 리스트 반환
        return Arrays.asList("AAA", "BBB", "CCC");
    }
}

SampleController의 doA()는 '/api/sample/doA' 
경로로 호출이 가능하므로 프로젝트를 실행해서 이를 확인하고 
'/swagger-ui/index.html 에서 
Swagger UI가 동작하는지 확인합니다.

___

__
• Ajax 호출 확인

REST 방식으로 동작하게될 예제 프로젝트는 
별도의 클라이언트에서 API를 호출해서 사용하기 
때문에 별도의 서버를 구성하고 

Ajax를 이용해서 서버를 호출하는 것이 일반적입니다. 
다만 현재 예제에서는 별도의 서버를 구성하는 일을 최소화하고자 
프로젝트에 html 파일을 생성하고 이를 이용해서 

API 서버를 사용하도록 구성해 봅니다. 
별도의 서버에서 API 서버를 호출하는 작업은 조금 더 
뒤쪽에서 다루도록 합니다.

프로젝트의 static 폴더에 sample.html 파일을 생성합
니다.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Title</title>
</head>
<body>
    <h1>Sample Client</h1>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script>
        // JavaScript 코드 추가 가능
        console.log("Axios loaded successfully!");
    </script>
</body>
</html>


___

프로젝트를 실행하고 예전처럼 sample.html'을 호출하면 
정상적으로 처리되지 못한 에러 화면을 보게 됩니다. 
에러의 원인은 Thymeleaf가 없는 환경에서 
스프링 MVC의 모든 경로를 스프링에서 처리하려고 시도하기 때문입니다.

예제를 이전과 달리 중간에 '/files/로 시작하는 경로는 
스프링 MVC에서 일반 파일 경로로 처리하도록 지정해서 
사용하도록 구성해 봅니다.

config 패키지의 CustomServletConfig 클래스를 
다음과 같이 수정합니다.

package com.busanit501.api5012.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@EnableWebMvc
public class CustomServletConfig implements WebMvcConfigurer {

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry
                .addResourceHandler("/files/**") // 요청 경로 매핑
                .addResourceLocations("classpath:/static/"); // 실제 리소스 위치
    }
}


브라우저에는 'files' 경로가 추가된 
'/files/sample.html'을 호출했을 때 
정상적인 결과를 확인할 수 있습니다.


sample.html에서는 Axios를 이용해서 작성되어 있는
http://localhost:8080/api/sample/doA'를 호출해 봅니다.

<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    async function callTest() {
        try {
            // API 호출
            const response = await axios.get("http://localhost:8080/api/sample/doA");
            return response.data;
        } catch (e) {
            // 오류 처리
            console.error("Error occurred:", e);
        }
    }

    // 함수 호출 및 결과 처리
    callTest()
        .then(data => console.log(data))
        .catch(e => console.error("Promise error:", e));
</script>


호출 결과는 다음과 같이 console.log()를 이용해서 
브라우저에 출력한 것을 확인합니다.


API 사용자 처리

Ajax를 이용해서 API 서버를 호출하는 처리에 문제가 없고 
@RestController의 동작을 확인했다면 API 서버를 통해서 
토큰들을 얻을 수 있는 사용자들에 대한 처리를 진행합니다.

이 부분은 이전 예제에서 로그인 처리가 된 사용자를 
그대로 이용할 수 있겠지만 
현재 예제 에서는 사용자들을 직접 생성해서 처리하도록 합니다.

추가하려는 사용자는 스프링 시큐리티를 통해서 
처리되는 것이 아니기 때문에 

간단히 아이디와 패스워드를 이용해서 토큰 생성을 
요청한다고 가정하고 예제를 작성하도록 합니다.

API 사용자는 별도의 domain 패키지를 구성해서 엔티티
클래스를 추가하고 Repository와 서비스 계층을 구성합니다.


API 사용자는 APIUser라는 이름으로 클래스를 생성합니다.

package com.busanit501.api5012.domain;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import lombok.*;

@Entity
@Getter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@ToString
public class APIUser {

    @Id // Primary Key 설정
    private String mid; // 사용자 ID

    private String mpw; // 사용자 비밀번호

    // 비밀번호 변경 메서드
    public void changePw(String mpw) {
        this.mpw = mpw;
    }
}


APIUser는 일반 웹 서비스와 달리 Access Key를 발급받을 때 
자신의 mid와 mpw를 이용하므로 
다른 정보들 없이 구성하였습니다

(스프링 시큐리티에서 사용하는 권한으로 
예제에서는 'ROLE_USER'를 추가해서 사용할 것입니다).

repository 패키지를 생성하고 
APlUserRepository 인터페이스를 추가합니다.

package com.busanit501.api5012.repository;

import com.busanit501.api5012.domain.APIUser;
import org.springframework.data.jpa.repository.JpaRepository;

@Repository
public interface APlUserRepository extends JpaRepository<APIUser, String> {
}


• APIUser 데이터 생성과 확인

APIUser를 이용하기 위해서 테스트 코드로 
여러 명의 API 사용자를 미리 생성해 두도록 합니다.

test 폴더에 repository 패키지와 
APIUserRepositoryTests 클래스를 추가합니다.


작성된 테스트 클래스에는 
PasswordEncoder와 APIUserRepository를 @Autowired로 주입합니다.

package com.busanit501.api5012.repository;

import com.busanit501.api5012.domain.APIUser;
import lombok.extern.log4j.Log4j2;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.stream.IntStream;

@SpringBootTest
@Log4j2
public class APIUserRepositoryTests {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private APlUserRepository apiUserRepository;

    @Test
    public void testInserts() {
        IntStream.rangeClosed(1, 100).forEach(i -> {
            // APIUser 객체 생성
            APIUser apiUser = APIUser.builder()
                    .mid("apiuser" + i) // 사용자 ID 설정
                    .mpw(passwordEncoder.encode("11111")) // 비밀번호 암호화
                    .build();

            // 데이터 저장
            apiUserRepository.save(apiUser);

            // 로그 출력
            log.info("Saved APIUser: " + apiUser);
        });
    }
}


testInserts()를 실행해서 데이터베이스에 insert 합니다.
'apiuser.'로 100개의 데이터가 생성되는 것을 확인합니다.


• 스프링 시큐리티의 UserDetailsService와 DTO

사용자들의 인증 자체는 스프링 시큐리티의 기능을 
그대로 활용하도록 구성해 봅니다. 

프로젝트에 security 패키지를 추가하고 스프링 시큐리티의
UserDetailsService 인터페이스를 구현하는 
APIUserDetailsService 클래스를 추가합니다.


package com.busanit501.api5012.security;

import com.busanit501.api5012.repository.APlUserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
@Log4j2
@RequiredArgsConstructor
public class APIUserDetailsService implements UserDetailsService {

    // Repository 주입
    private final APlUserRepository apiUserRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 데이터베이스에서 사용자 정보 조회
       return null;
    }
}


loadUserByUsername()의 결과를 처리하기 위해서 
dto 패키지와 APIUserDTO 클래스를 추가합니다. 

APIUserDTO 클래스는 스프링 시큐리티의 
User 클래스를 상속해서 구성합니다.


package com.busanit501.api5012.dto;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.User;

import java.util.Collection;

@Getter
@Setter
@ToString
public class APIUserDTO extends User {

    private String mid; // 사용자 ID
    private String mpw; // 사용자 비밀번호

    // 생성자
    public APIUserDTO(String username, String password, Collection<GrantedAuthority> authorities) {
        super(username, password, authorities); // 부모 클래스(User)의 생성자 호출
        this.mid = username;
        this.mpw = password;
    }
}



APIUserDetailsService의 loadUserByUsername() 내부에는 
해당 사용자가 존재할 때 APIUserDTO를 반환하도록 
코드를 완성합니다
(이 과정에서 모든 사용자는 ROLE_USER' 권한을 가지도록 구성합니다)

APIUserDetailsService, 코드 변경

 @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 사용자 정보 조회
        Optional<APIUser> result = apiUserRepository.findById(username);

        // 사용자 정보가 없을 경우 예외 처리
        APIUser apiUser = result.orElseThrow(() ->
                new UsernameNotFoundException("Cannot find user with username: " + username)
        );

        // 사용자 정보 로깅
        log.info("APIUserDetailsService - Found APIUser: {}", apiUser);

        // APIUserDTO 생성
        APIUserDTO dto = new APIUserDTO(
                apiUser.getMid(), // 사용자 ID
                apiUser.getMpw(), // 사용자 비밀번호
                List.of(new SimpleGrantedAuthority("ROLE_USER")) // 권한 설정
        );

        // DTO 정보 로깅
        log.info("APIUserDetailsService - Created APIUserDTO: {}", dto);

        // UserDetails 반환
        return dto;
    }


토큰 인증을 위한 시큐리티 필터

스프링 시큐리티는 수많은 필터로 구성되어 있고, 
이를 이용해서 컨트롤러에 도달하기 전에 
필요한 인증 처리를 진행할 수 있습니다. 

예제에서는 다음과 같은 기능 구현에 필터를 이용하도록 합니다.

1 사용자가 자신의 아이디(mid)와 패스워드(mpw)를 이용해서 
AccessToken과 Refresh Token을 얻으려는 단계를 구현

2 사용자가 Access Token을 이용해서 컨트롤러를 호출하고자 할 때 
인증과 권한을 체크하는 기능을 구현


인증과 JWT 발행 처리

사용자의 아이디(mid)와 패스워드(mpw)를 이용해서 
JWT 문자열을 발행하는 기능은 컨트롤러를 이용할 수도 있지만 

스프링 시큐리티의 AbstractAuthenticationProcessingFilter
클래스를 이용하면 
좀 더 완전한 분리가 가능합니다.

예제에서는 APILoginFilter라는 필터를 이용해서 
인증 단계를 처리하고 
인증에 성공했을 때는 AccessToken과 RefreshToken을 
전송하도록 구성해 봅니다.


security 패키지에 filter 패키지를 추가하고 
AbstractAuthenticationProcessingFilter 
클래스를 상속받는 
APILoginFilter 를 작성합니다. 

APILoginFilter는 부모 클래스 
AbstractAuthenticationProcessingFilter의 영향으로 생성자와
추상 메소드를 오버라이드 해주어야만 합니다
(설정을 위해서 생성자는 public으로 변경해 두도록 합니다).


package com.busanit501.api5012.security.filter;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.log4j.Log4j2;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;

import java.io.IOException;

@Log4j2
public class APILoginFilter extends AbstractAuthenticationProcessingFilter {

    // 생성자: 기본 필터 URL 설정
    public APILoginFilter(String defaultFilterProcessesUrl) {
        super(defaultFilterProcessesUrl);
    }

    @Override
    public Authentication attemptAuthentication(
            HttpServletRequest request,
            HttpServletResponse response
    ) throws IOException, ServletException {
        // 로깅: 필터 동작 확인
        log.info("APILoginFilter - attemptAuthentication executed");

        // 인증 로직 미구현 상태
        return null;
    }
}


• AbstractAuthenticationProcessingFilter 설정

AbstractAuthentication ProcessingFilter는 
로그인 처리를 담당하기 때문에 다른 필터들과 
달리 로그인을 처리하는 경로에 대한 설정과 
실제 인증 처리를 담당하는 AuthenticationManager 
객체의 설정이 필수로 필요합니다. 
이에 대한 설정은 CustomSecurityConfg를 이용해서 처리합니다.

CustomSecurityConfig에는 APIUserDetailsService를 
주입하도록 설정합니다. 
이를 이용해서 AuthenticationManager를 생성하고 
APILoginFilter를 설정합니다.

package com.busanit501.api5012.config;

import com.busanit501.api5012.security.APIUserDetailsService;
import com.busanit501.api5012.security.filter.APILoginFilter;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Log4j2
@Configuration
// 어노테이션을 이용해서, 특정 권한 있는 페이지 접근시, 구분가능.
//@EnableGlobalMethodSecurity(prePostEnabled = true)
// 위 어노테이션 지원중단, 아래 어노테이션 으로 교체, 기본으로 prePostEnabled = true ,
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class CustomSecurityConfig {
    private final APIUserDetailsService apiUserDetailsService;

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        log.info("시큐리티 동작 확인 ====webSecurityCustomizer======================");
        return (web) ->
                web.ignoring()
                        .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        log.info("===========config=================");

        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

        authenticationManagerBuilder
                .userDetailsService(apiUserDetailsService)
                .passwordEncoder(passwordEncoder());

        // Get AuthenticationManager 세팅1
        AuthenticationManager authenticationManager =
                authenticationManagerBuilder.build();

        //반드시 필요 세팅1
        http.authenticationManager(authenticationManager);

        //APILoginFilter 세팅1
        APILoginFilter apiLoginFilter = new APILoginFilter("/generateToken");
        apiLoginFilter.setAuthenticationManager(authenticationManager);


        //APILoginFilter의 위치 조정 세팅1, 사용자 인증 전에 ,
        http.addFilterBefore(apiLoginFilter, UsernamePasswordAuthenticationFilter.class);

        http.csrf(httpSecurityCsrfConfigurer -> httpSecurityCsrfConfigurer.disable());
        http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        return http.build();
    }


}



앞의 코드에서 APILoginFilter는 generateToken 이라는 
경로로 지정되었고,
 
스프링 시큐리티에서 username과 password를 처리하는 
UsernamePasswordAuthenticationFilter의 
앞쪽으로 동작하도록 설정되었습니다.

프로젝트를 실행하고 브라우저를 
'/generateToken' 경로를 호출하면 APILoginFilter가 
실행되는 것을 확인할 수 있습니다.


APILoginFilter의 JSON 처리

APILoginFilter는 사용자의 아이디(mid)와 패스워드(mpw)를 이용해서 
JWT 문자열을 생성하는 기능을 수행하기 위해서 
사용자가 전달하는 mid, mpw 값을 알아낼 수 있어야만 합니다. 

API 서버는 POST 방식으로 JSON 문자열을 이용하는 것이 
일반적이므로 이를 APILoginFilter에 반영하도록 합니다.


• 인증 정보 JSON 문자열 처리

JWT 문자열들을 얻기 위해서 전송되는 mid, mpw는 
JSON 문자열로 전송되므로 
HttpServletRequest로 처리하려면 
JSON 처리를 쉽게 할 수 있는 라이브러리를 활용하도록 합니다.

build.gradle 파일에 Gson 라이브러리를 추가합니다.


dependencies {
// https://mvnrepository.com/artifact/com.google.code.gson/gson
implementation 'com.google.code.gson:gson:2.11.0'

｝

APILoginFilter는 POST 방식으로 요청이 들어올 때 
JSON 문자열을 처리하는 parseRequestJSON() 메소드를 구성하고 
mid와 mpw를 확인할 수 있도록 합니다.


package com.busanit501.api5012.security.filter;

import com.google.gson.Gson;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.log4j.Log4j2;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Map;

@Log4j2
public class APILoginFilter extends AbstractAuthenticationProcessingFilter {

    public APILoginFilter(String defaultFilterProcessesUrl) {
        super(defaultFilterProcessesUrl); // 로그인 엔드포인트 설정
    }

    @Override
    public Authentication attemptAuthentication(
            HttpServletRequest request,
            HttpServletResponse response
    ) throws IOException, ServletException {
        log.info("APILoginFilter - attemptAuthentication called");

        // GET 요청은 지원하지 않음
        if (request.getMethod().equalsIgnoreCase("GET")) {
            log.info("GET METHOD NOT SUPPORTED");
            return null;
        }

        // JSON 데이터 파싱
        Map<String, String> jsonData = parseRequestJSON(request);
        log.info("Parsed JSON Data: {}", jsonData);

        // TODO: 인증 로직 추가
        return null;
    }

    private Map<String, String> parseRequestJSON(HttpServletRequest request) {
        // JSON 데이터를 파싱하여 mid와 mpw 값을 Map으로 처리
        try (Reader reader = new InputStreamReader(request.getInputStream())) {
            Gson gson = new Gson();
            return gson.fromJson(reader, Map.class);
        } catch (Exception e) {
            log.error("Error parsing JSON request: {}", e.getMessage());
        }
        return null;
    }
}


__
변경된 APILoginFilter는 POST 방식으로 동작해야 전송된
JSON 데이터를 처리하므로 
static 폴더에 apiLogin.html 파일을 다음과 같이 추가합니다.

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generate Token</title>
</head>
<body>
<button class="btn1">Generate Token</button>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    // 버튼 클릭 이벤트 처리
    document.querySelector(".btn1").addEventListener("click", () => {
        const data = {
            mid: "apiuser10", // 사용자 ID
            mpw: "11111" // 사용자 비밀번호
        };

        // Axios를 사용하여 POST 요청 보내기
        axios.post("http://localhost:8080/generateToken", data)
            .then(response => {
                // 성공 응답 처리
                console.log("Token generated:", response.data);
                alert("Token: " + response.data.token);
            })
            .catch(error => {
                // 오류 응답 처리
                console.error("Error generating token:", error);
                alert("Error generating token");
            });
    }, false);
</script>
</body>
</html>


http://localhost:8080/files/apiLogin.html

apilogin.html은 화면상의 [generate Token] 버튼을 클릭하면 
Axios를 이용해서 POST 방식으로 generateToken'을 호출하고 
이때 JSON 문자열을 전송하게 됩니다. 

서버에는  음과 같이 전송된 JSON을 파싱해서 
mid와 mpw 값을 알아낼 수 있습니다.


Map으로 처리된 mid, mpw를 이용해서 로그인을 처리하는 부분은 
UsernamePasswordAuthenticationToken 인증 정보를 만들어서 
다음 필터(UsernamePasswordAuthenticationFilter)에서 
하도록 구성합니다.

...
@Override
    public Authentication attemptAuthentication(
            HttpServletRequest request,
            HttpServletResponse response
    ) throws IOException, ServletException {
        log.info("APILoginFilter - attemptAuthentication called");

        // GET 요청은 지원하지 않음
        if (request.getMethod().equalsIgnoreCase("GET")) {
            log.info("GET METHOD NOT SUPPORTED");
            return null;
        }

        // JSON 데이터 파싱
        Map<String, String> jsonData = parseRequestJSON(request);
        log.info("Parsed JSON Data: {}", jsonData);

        // TODO: 인증 로직 추가
        // JSON 데이터에서 사용자 ID와 비밀번호를 추출하여 인증 토큰 생성
        UsernamePasswordAuthenticationToken authenticationToken =
                new UsernamePasswordAuthenticationToken(
                        jsonData.get("mid"), // 사용자 ID
                        jsonData.get("mpw")  // 사용자 비밀번호
                );

        // AuthenticationManager를 사용하여 인증 시도
        return getAuthenticationManager().authenticate(authenticationToken);
    }
...

정상적인 mid와 pw 값이 전달되면 
다음과 같이 SQL이 실행되고 APlUserDetailaService를 
이용한 인증 처리가 되는 것을 확인할 수 있습니다.

• 인증 성공 처리
인증 처리되기는 했지만, 기존의 스프링 시큐리티처럼 로그인 후 
'/'와 같이 화면을 이동하는 방식으로 동작하는 것을 확인할 수 있습니다.
원하는 작업은 JWT 문자열을 생성하는 것 이므로 
이에 대한 처리를 위해서 인증 성공 후 
처리 작업을 담당하는 
AuthenticationSuccessHandler를 이용해서 후처리를 진행합니다.


security 패키지에 handler라는 패키지를 추가하고


APILoginSuccessHandler를 추가합니다.

package com.busanit501.api5012.security.handler;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;

import java.io.IOException;

@Log4j2
@RequiredArgsConstructor
public class APILoginSuccessHandler implements AuthenticationSuccessHandler {

    @Override
    public void onAuthenticationSuccess(
            HttpServletRequest request,
            HttpServletResponse response,
            Authentication authentication
    ) throws IOException, ServletException {
        // 로그인 성공 시 동작 로직
        log.info("Login Success Handler triggered");

        // TODO: JWT 생성 및 응답으로 반환
    }
}

APILoginSuccesHandler의 동작은 APILoginFilter
와 연동되어야 하므로 CustomSecurityConfig 
내부에서 이를 설정합니다.
기존에 APILoginFilter를 적용한 부분에 
다음과 같이 APILoginSuccessHandler를 추가 합니다.

...
// APILoginFilter 생성 및 AuthenticationManager 설정
        APILoginFilter apiLoginFilter = new APILoginFilter("/generateToken"); // 로그인 엔드포인트 설정
        apiLoginFilter.setAuthenticationManager(authenticationManager); // APILoginFilter에서 사용할 AuthenticationManager 설정

  // APILoginSuccessHandler 생성: 인증 성공 후 처리 로직을 담당
        APILoginSuccessHandler successHandler = new APILoginSuccessHandler();

// SuccessHandler 설정: 로그인 성공 시 APILoginSuccessHandler가 호출되도록 설정
        apiLoginFilter.setAuthenticationSuccessHandler(successHandler);
...		

프로젝트를 실행하고 
'/files/apiLogin.html'을 통해서 실행해 보면 
APILoginSuccessHandler가 동작하는 것을 확인할 수 있습니다.

토큰 생성 과정에서 남은 작업은 
APILoginSuccessHandler에서 Acces Token과
Refresh Token을 생성해서 전송하는 작업입니다. 
이를 위해서는 JWT 문자열을 처리하는 방법을 학습할 필요가 있습니다.
 
 
JWT 문자열의 생성과 검증
JWT는 엄밀히 말해서 '인코딩된 문자열'입니다. 
JWT는 크게 '헤더(header), 페이로드 (payload), 
서명(signature) 부분으로 작성되어 있는데 
각 부분은 '을 이용해서 구분됩니다. 

세 부분 중에 페이로드에는 클레임(claim)이라고 
부르는 키(key)/값(value)으로 구성된 정보들을 저장합니다.

헤더
eyJhbGc101JIUzIniIsInR5cCI6IkpXVCJ9
JzdWI101IxMjMONTY30DkwIiwibmFtzSI6Ikpva 64gRG91IiwiaWFOIjoxNTE2MjM5DIyfO.
페이로드
서명

JWT 문자열이 어떤 형태인지 가장 쉽게 알 수 있는 방법은
'https://jwt.io' 사이트에서 만들어진 예제를 활용하는 방법입니다.

앞의 화면과 같이 JWT 문자열은 각 부분에 정해진 속성을 가지고 있는데 
마지막 서명 부분에 비밀키를 지정해서 인코딩합니다. 
오른쪽 아래에 문자열을 변경하면 Encoded 결과가 
달라지는 것을 확인할 수 있습니다.

JWT 문자열의 각 부분은 다음과 같이 구성됩니다.
Header 
  typ(Type) : 토큰 타입
  alg(Algorithm) : 해싱 알고리즘
Payload 
  iss(Issuer) : 토큰 발급자 
  sub(Subject) : 토큰 제목 
  exp(Expiration Time,UNIX 시간) : 토큰 만료 시간 
  iat(Issued At,UNIX 시간) : 토큰 발급 시간 
  aud(Audience) : 토큰 대상자 
  nbf(Not Before) : 토큰 활성 시간 
  jti(JWT ID) : JWT 고육 식별자 
signature , Header 의 인코딩 + Payload의 인코딩값을 해싱 + 비밀키 



개발자의 고민은 어떻게 JWT를 생성하고 
넘겨받은 JWT를 확인 할 수 있는가 입니다. 

이 부분은 JWT와 관련된 라이브러리를 이용해서 
처리하는데 여러 종류의 라이브러리가 존재 하므로 
해당 라이브러리의 문서를 확인하면서 개발해야 합니다.

예제에서는 가장 흔히 사용하는 
i0.jsonwebtoken(이하 jjwt) 라이브러리를 이용하도록 합니다. 
인터넷에서 가장 쉽게 찾을 수 있는 버전은 
0.9.1이므로 이를 이용해서 JWT를 생성하고 검증하도록 합니다
(io.jsonwebtoken의 공식 문서 버전은 0.11.1이지만 
비밀키의 길이나 기타 메소드들이 조금 다르므로 
가장 많이 사용되는 0.9.1 버전을 이용하도록 합니다).


build.gradle에 라이브러리를 추가합니다.

dependencies {
implementation 'io.jsonwebtoken:jjwt :0.9.1'
}

새로운 버전1, 사용
  // https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-api
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
// https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-impl
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
// https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-jackson
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'

새로운 버전2-> 문법 구조 변경. 
공식 문서 참고, : https://github.com/jwtk/jjwt/blob/master/README.adoc#quickstart

  // https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-api
    implementation 'io.jsonwebtoken:jjwt-api:0.12.6'
// https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-impl
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.12.6'
// https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-jackson
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.12.6'


JWT를 쉽게 이용하기 위해서 프로젝트에 util 패키지를 생성 하고 
JWTUtil 클래스를 추가합니다.

package com.busanit501.api5012.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;

@Log4j2
@Component
public class JWTUtil {

    @Value("${com.busanit5012.jwt.secret}") // 비밀키를 외부 설정에서 가져옴
    private String key;


    public String generateToken(Map<String, Object> valueMap, int days) {
        log.info("Generating token with secret key: {}", key);
        return null;
    }


    public Map<String, Object> validateToken(String token) throws JwtException {
        log.info("Validating token: {}", token);

       Map<String, Object> claims = null;
        return claims;
    }
}

JWTUtil에서 필요한 기능은 크게 JWT 문자열을 생성하는 기능인 
generateToken()과 
토큰을 검증하는 validateTOken() 기능입니다.

JWTUtil에서 서명을 처리하기 위해서 비밀키가 필요한 데 
이 부분은 application.properties에 추가해서 사용합니다.

// JWT에서 사용할 비밀키
com.busanit5012.jwt.secret=busainit501234567890busainit501234567890busainit501234567890

• JWTUtil의 테스트 환경 구성

JWT를 테스트 하는 방법은 다음과 같은 단계를 통해서 확인하도록 합니다.

1 JWTUtil을 이용해서 JWT 문자열 생성

2 생성된 문자열을 https://jwt.io 사이트를 통해서 정상적인지 검사

3 JWTUtil의 validateToken()을 통해서 
jwt.io 사이트의 검사결과와 일치하는지 확인

test 폴더에는 util 패키지를 추가하고 
JWTUtilTests라는 테스트 클래스를 작성합니다.


package com.busanit501.api5012.util;

import lombok.extern.log4j.Log4j2;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.Map;

@SpringBootTest
@Log4j2
public class JWTUtilTests {

    @Autowired
    private JWTUtil jwtUtil;

    /**
     * JWT 토큰 생성 테스트
     */
    @Test
    public void testGenerate() {
        // Claims 데이터 생성
        Map<String, Object> claimMap = Map.of("mid", "ABCDE");

        // 1일 동안 유효한 JWT 생성
        String jwtStr = jwtUtil.generateToken(claimMap, 1);

        // 생성된 JWT 출력
        log.info("Generated JWT: {}", jwtStr);
    }
}


아직까지 JWT 생성 자체는 안되지만 
application.properties 파일에 설정된 비밀키가 
정상적으로 로딩되는지 확인할 수 있습니다.


• JWT 생성과 확인

JWTUtil에서 실제 JWT를 생성하기 위해서 
generateToken()는 다음과 같이 수정합니다.


package com.busanit501.api5012.util;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.time.ZonedDateTime;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@Log4j2
@Component
public class JWTUtil {

    @Value("${com.busanit5012.jwt.secret}") // 비밀키를 외부 설정에서 가져옴
    private String key;


    public String generateToken(Map<String, Object> valueMap, int days) {
        log.info("Generating token with secret key: {}", key);
        // 헤더 설정
        Map<String, Object> headers = new HashMap<>();
        headers.put("typ", "JWT");
        headers.put("alg", "HS256");

        // 페이로드 설정
        Map<String, Object> payloads = new HashMap<>();
        payloads.putAll(valueMap);

        // 테스트 환경에서는 분 단위, 운영 환경에서는 일 단위로 설정
        int time = days; // 테스트 시 분 단위 (나중에 60 * 24로 변경 가능)

        // JWT 생성
        String jwtStr = Jwts.builder()
                .setHeader(headers) // 헤더 추가
                .setClaims(payloads) // 페이로드 추가
                .setIssuedAt(Date.from(ZonedDateTime.now().toInstant())) // 발급 시간
                .setExpiration(Date.from(ZonedDateTime.now().plusMinutes(time).toInstant())) // 만료 시간
                .signWith(SignatureAlgorithm.HS256, key.getBytes()) // 서명 알고리즘 및 비밀키 설정
                .compact();

        log.info("Generated JWT: {}", jwtStr);
        return jwtStr;
    }


    public Map<String, Object> validateToken(String token) throws JwtException {
        log.info("Validating token: {}", token);

       Map<String, Object> claims = null;
        return claims;
    }
}


특별히 주의 깊게 봐야 하는 부분은 JWT 생성시 
유효 기간을 days라는 파라미터로 처리 했지만 

실제로는 plusMinutes()를 이용했으므로 분 단위로 처리되도록 
작성된 부분입니다.
이는 짧은 유효 기간이 테스트 시에 유용하기 때문인데 
개발이 완료되면 plusDays()로 변경 해 줄 필요가 있습니다.

Jwts.builder()를 이용해서
Header 부분과 Payload 부분 등을 지정하고 
발행 시간과 서명 을 이용해서 compact()를 수행하면 
JWT 문자열이 생성됩니다. 

테스트 코드를 실행하면 매번 새로운 문자열이 
생성된 것을 확인할 수 있습니다.


생성된 문자열은 기록을 위해 별도의 메모장을 이용해서 
복사해 두도록 합니다(잠시 후에 JWT 검증 테스트 시에 사용).
생성된 JWT 문자열이 정상적인지 확인하기 위해서 
https://jwt.io 사이트 기능을 이용합니다. 

우선 비밀키(key) 값을 먼저 입력합니다. 
비밀키가 변경되면 JWT 문자열이 변경되므로 
반드시 비밀키를 먼저 입력해 두고 
이후에 생성된 JWT 문자열을 입력합니다.


화면의 Decoded에서 가장 중요한 결과는 PAYLOAD 항목에 있는 
'exp' 값입니다. 
마우스를 오버하면 시간이 변환되어서 나오는데 
현재 JWT 토큰의 유효 시간은 1분으로 지정되므로 이를 확인하도록 합니다.

다음 그림은 생성 시간(iat)이 16시 58분이지만 
만료 시간(exp)은 16시 59분으로 지정된 것을 확인할 수 있습니다.


유효 시간은 다음 내용인 JWT 문자열 검증 단계에서 
날짜 단위로 처리할 예정이지만 

테스트 단계에서는 분 단위로 확인하도록 합니다.


• JWT문자열 검증
JWTUtil을 이용해서 JWT 문자열을 검증할 때 
가장 중요한 부분은 여러 종류의 예외가 발생하고 
발생하는 예외를 JwtException이라는 
상위 타입의 예외로 던지도록 구성하는 점 입니다.

검증은 JWT 문자열 자체의 구성이 잘못되었거나, 
JWT 문자열의 유효 시간이 지났거나, 
서명에 문제가 있는 등의 여러 문제가 발생할 수 있습니다. 
이 검증은 추가된 라이브러리의 Jwts.parser()를 이용해서 처리됩니다.

JWTUtil의 validateToken()은 다음과 같이 수정합니다.

 public Map<String, Object> validateToken(String token) throws JwtException {
        log.info("Validating token: {}", token);

       Map<String, Object> claims = null;
        // Claims 파싱 및 검증
        claims = Jwts.parser()
                .setSigningKey(key.getBytes()) // 비밀키 설정
                .parseClaimsJws(token) // 토큰 파싱 및 검증
                .getBody();

        // Claims 데이터를 Map으로 변환
        Map<String, Object> claimMap = new HashMap<>(claims);

        log.info("Token is valid. Extracted Claims: {}", claimMap);
        return claimMap;
    }


테스트 코드는 이미 유효 기간이 지난 
JWT 문자열(이전 테 스트 결과)을 이용해서 
validate Token()을 실행해 봅니다.


 @Test
    public void testValidate() {
        // 유효 시간이 지난 토큰
        String jwtStr = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJtaWQiOiJBQkNERSIsImlhdCI6MTczNzcwMjIzMiwiZXhwIjoxNzM3NzAyMjkyfQ.0SshOFXnpn1mtXfFB2PJexYhfgH3n-70OIU-DWUb-o43";

        try {
            // 토큰 검증 및 Claims 추출
            Map<String, Object> claim = jwtUtil.validateToken(jwtStr);

            // Claims 출력
            log.info("Extracted Claims: {}", claim);
        } catch (JwtException e) {
            // 토큰 검증 실패 처리
            log.error("Token validation failed: {}", e.getMessage());
        }
    }


앞선 코드의 토큰은 이미 유효 시간이 지났으므로 
다음과 같이 Expired.JwtException 
예외가 발생하는 것을 알 수 있습니다.

만일 고의로 문자열의 마지막 부분에 임의의 문자를 추가하면 
서명(마지막 부분)에서 Sig-natureException 예외가 발생하는 것을 
확인할 수 있습니다.


•JWTUtil의 유효 기간


정상적인지를 확인하기 위해 JWTUtil에서 유효 기간을 
일(day) 단위로 변경합니다.

   public String generateToken(Map<String, Object> valueMap, int days) {
        log.info("Generating token with secret key: {}", key);
        // 헤더 설정
        Map<String, Object> headers = new HashMap<>();
        headers.put("typ", "JWT");
        headers.put("alg", "HS256");

        // 페이로드 설정
        Map<String, Object> payloads = new HashMap<>();
        payloads.putAll(valueMap);

        // 테스트 환경에서는 분 단위, 운영 환경에서는 일 단위로 설정
        int time = days * 60 * 24 ; // 테스트 시 분 단위 (나중에 60 * 24로 변경 가능)

        // JWT 생성
        String jwtStr = Jwts.builder()
                .setHeader(headers) // 헤더 추가
                .setClaims(payloads) // 페이로드 추가
                .setIssuedAt(Date.from(ZonedDateTime.now().toInstant())) // 발급 시간
                .setExpiration(Date.from(ZonedDateTime.now().plusMinutes(time).toInstant())) // 만료 시간
                .signWith(SignatureAlgorithm.HS256, key.getBytes()) // 서명 알고리즘 및 비밀키 설정
                .compact();


        log.info("Generated JWT: {}", jwtStr);
        return jwtStr;
    }

테스트 코드에는 JWT 문자열을 생성해서 
이를 검증하는 작업을 같이 수행하는 테스트 메소드를 작성해 봅니다.

 @Test
    public void testAll() {
        // JWT 생성
        String jwtStr = jwtUtil.generateToken(
                Map.of("mid", "AAAA", "email", "aaaa@bbb.com"), 1
        );
        log.info("Generated JWT: {}", jwtStr);

        // JWT 검증 및 Claims 추출
        Map<String, Object> claim = jwtUtil.validateToken(jwtStr);

        // Claims 출력
        log.info("MID: {}", claim.get("mid"));
        log.info("EMAIL: {}", claim.get("email"));
    }



testAll()에서는 mid와 email을 이용해서 JWT 문자열을 생성하고 
validateToken()을 실행합니다. 

validate Token()의 리턴값에는 mid와 email이 
그대로 들어있는 것을 확인할 수 있습니다.


Access Token 발행

JWTUtil을 이용해서 JWT 관련 문자열(토큰)을 만들거나 검
증할 수 있다는 사실을 알았다면 

이제는 이를 언제 어떻게 활용해야 하는지를 다시 점검하고 구현해야 합니다.
사용자가 generateToken'을 POST 방식으로 
필요한 정보(mid,mpw)를 전달하면 APILoginFilter가 동작하고 
인증 처리가 된 후에는 APILoginSuccessHandler가 동작하게 됩니다.

APILoginSuccessHandler의 내부에서는 인증된 사용자에게 
AccessToken/RefreshToken을 발행해 주기 위해서 
JWTUtil을 이용해야 합니다.


JWTUtil 주입

APILoginSuccessHandler는 다음과 같이 
JWTUtil을 주입받고 필요한 토큰들을 생성하 도록 수정합니다.

package com.busanit501.api5012.security.handler;

import com.busanit501.api5012.util.JWTUtil;
import com.google.gson.Gson;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.AuthenticationSuccessHandler;

import java.io.IOException;
import java.util.Map;

@Log4j2
@RequiredArgsConstructor
public class APILoginSuccessHandler implements AuthenticationSuccessHandler {
    private final JWTUtil jwtUtil;
    
    @Override
    public void onAuthenticationSuccess(
            HttpServletRequest request,
            HttpServletResponse response,
            Authentication authentication
    ) throws IOException, ServletException {
        // 로그인 성공 시 동작 로직
        log.info("Login Success Handler triggered");

        // 응답 Content-Type 설정
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);

        // 인증 정보 로그 출력
        log.info("Authentication: {}", authentication);
        log.info("Authenticated Username: {}", authentication.getName());

        // 클레임 설정 (사용자 이름 포함)
        Map<String, Object> claims = Map.of("mid", authentication.getName());

        // Access Token 유효기간: 1일
        String accessToken = jwtUtil.generateToken(claims, 1);

        // Refresh Token 유효기간: 30일
        String refreshToken = jwtUtil.generateToken(claims, 30);

        // JSON 형식 응답 생성
        Gson gson = new Gson();
        Map<String, String> keyMap = Map.of(
                "accessToken", accessToken,
                "refreshToken", refreshToken
        );
        String jsonStr = gson.toJson(keyMap);

        // 응답으로 JSON 전송
        response.getWriter().println(jsonStr);
    }
}


config 패키지의 CustoemScurityConfig에 우선 JWTUtil을 주입하고 
APILoginStuccessHandler에 이를 주입 합니다.



public class CustomSecurityConfig {
//추가
private final APIUserDetailsService apiUserDetailsService;
private final JWTUtil jwtUtil;
... 생략 ...
@Bean
public SecurityFilterChain filterchain(final HttpSecurity http) throws

... 생략 ...
   // 교체
        APILoginSuccessHandler successHandler = new APILoginSuccessHandler(jwtUtil);

// SuccessHandler 설정: 로그인 성공 시 APILoginSuccessHandler가 호출되도록 설정
        apiLoginFilter.setAuthenticationSuccessHandler(successHandler);
...생략 ..
}
}

__
생성된 토큰의 확인
설정이 완료되었다면 /files/apiLogin.html'을 이용해서 토큰들이 
정상적으로 생성되는지 확인합니다.

생성된 토큰은 https://jwt.io를 통해서 정상적인지 확인합니다
(반드시 비밀키를 먼저 입 력합니다). 
생성된 Acces Token과 Refresh Token의 만료 시간이 
원하는 대로 생성되었는지 확인합니다.


Access Token 검증 필터

Access Token과 Refresh Token의 발행이 가능해 졌다면 
특정한 경로를 호출할 때 이 토큰들을 검사하고 문제가 없을 때만 
접근 가능하도록 구성해볼 필요가 있습니다. 
이 작업은 스프링 시큐리티에서 필터를 추가해 처리하도록 구성합니다.

스프링 시큐리티가 웹 환경에서 동작할 때는 여러 종류의 필터를 
통해서 동작합니다. 
필터를 구성하는 일은 기존의 서블릿 기반 필터를 이용할 수도 있지만 
스프링 시큐리티는 다른 빈들을 연동해서 동작하는게 
가능하다는 장점이 있습니다.


TokenCheckFilter의 생성


프로젝트의 security/filter 패키지에 
TokenCheckFilter 클래스를 추가합니다. 
TokenCheckFilter는 현재 사용자가 로그인한 
사용자인지 체크 하는 로그인 체크용 필더와 유사하게 JWT 토큰을
검사하는 역할을 위해서 사용합니다.

TokenCheckFilter 는 
org.springframework.web.filter.OncePerRequestFilter를 상속해서 
구성하는데 OncePerRequestFilter는 
하나의 요청에 대해서 한번씩 동작하는 필터로 
서블릿 APT의 필터와 유사합니다.

구성하려는 TokenCheckFilter는 
JWTUtil의 validateToken() 기능을 활용해야 합니다.

package com.busanit501.api5012.security.filter;

import com.busanit501.api5012.util.JWTUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Log4j2
@RequiredArgsConstructor
public class TokenCheckFilter extends OncePerRequestFilter {

    private final JWTUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        // 요청 경로 가져오기
        String path = request.getRequestURI();

        // "/api/"로 시작하지 않는 경로는 필터 처리하지 않음
        if (!path.startsWith("/api/")) {
            filterChain.doFilter(request, response);
            return;
        }

        // 로그 출력
        log.info("Token Check Filter triggered...");
        log.info("JWTUtil instance: {}", jwtUtil);

        // 다음 필터로 요청 전달
        filterChain.doFilter(request, response);
    }
}


__
TokenCheckFilter? 설정은 CustomSecurityConfig를
이용해서 지정합니다.


 @Bean
    public SecurityFilterChain filterChain(final HttpSecurity http) throws Exception {
        log.info("---- Configuring Security Filter Chain ----");

		...

        // /api 경로에 대해 TokenCheckFilter 적용
        http.addFilterBefore(
                tokenCheckFilter(jwtUtil),
                UsernamePasswordAuthenticationFilter.class
        );

        // CSRF 비활성화 (REST API 환경에서 권장)
        http.csrf().disable();

        // 세션 관리 정책: STATELESS (JWT 기반 인증 사용)
        http.sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);

        // 빌드 후 SecurityFilterChain 반환
        return http.build();
    }

    private TokenCheckFilter tokenCheckFilter(JWTUtil jwtUtil) {
        return new TokenCheckFilter(jwtUtil);
    }


TokenCheckFilter의 동작은 프로젝트를 실행한 후에 
'api/sample/doA'를 실행해서 로그를 확인해 보도록 합니다.

__
TokenCheckFilter 내 토큰 추출

TokenCheckFilter는 'api/.'로 시작하는 모든 경로의 호출에 
사용될 것이고, 사용자는 해당 경로에 
다음과 같은 상황으로 접근하게 됩니다.

1 Access Token이 없는 경우 - 토큰이 없다는 메시지 전달 필요

2 Access Token이 잘못된 경우
(서명 혹은 구성, 기타 에러)- 잘못된 토큰이라는 메시지 전달 필요

3 Access Token이 존재하지만 
오래된(expired) 값인 경우 - 토큰을 갱신하라는 메시지 전달 필요

이처럼 다양한 상황을 처리하기 위해서 TokenCheckFilter는 
JWTUtil에서 발생하는 예외에 따른 처리를 세밀하게 처리해야 합니다.

• Access Token의 추출과 검증
토큰 검증 단계에서 가장 먼저 할 일은 
브라우저가 전송하는 Access Token을 추출하는 것 입니다. 
일반적으로 Access Token의 값은 HTTP Header 중에 
'Authorization'을 이용해서 전달됩니다. 

Authorization 헤더는 'type+ 인증값'으로 작성되는데 
type 값들은 'Basic, Bearer, Digest, HOBA, Mutual 등을 이용합니다. 
이 중에서 OAuth나 JWT는 Bearer'라는 타입을 이용합니다.

TokenCheckFilter에서는 별도의 메소드를 이용해서 
Authorization 헤더를 추출하고 
Access Token을 검사하도록 합니다.

Acess Token에 문제가 있는 경우를 대비해서 
security 패키지에 별도로 exception 패키지를 구성해서
AccessTokenException 이라는 예외 클래스를 미리 정의하도록 합니다.


AccessTokenException은 발생하는 예외의 종류를 
미리 enum으로 구분해 두고, 
나중에 에러 메시지를 전송할 수 있는 구조로 작성합니다.

package com.busanit501.api5012.security.exception;

import com.google.gson.Gson;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;

import java.io.IOException;
import java.util.Date;
import java.util.Map;

public class AccessTokenException extends RuntimeException {

    
    TOKEN_ERROR tokenError;

    public enum TOKEN_ERROR {
        UNACCEPT(401, "Token is null or too short"),
        BADTYPE(401, "Token type must be Bearer"),
        MALFORM(403, "Malformed Token"),
        BADSIGN(403, "Bad Signature Token"),
        EXPIRED(403, "Expired Token");

        private final int status;
        private final String msg;

        TOKEN_ERROR(int status, String msg) {
            this.status = status;
            this.msg = msg;
        }

        public int getStatus() {
            return this.status;
        }

        public String getMsg() {
            return this.msg;
        }
    }

    public AccessTokenException(TOKEN_ERROR error) {
        super(error.name());
        this.tokenError = error;
    }

    public void sendResponseError(HttpServletResponse response) {
        response.setStatus(tokenError.getStatus());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);

        Gson gson = new Gson();
        String responseStr = gson.toJson(Map.of(
                "msg", tokenError.getMsg(),
                "time", new Date()
        ));

        try {
            response.getWriter().println(responseStr);
        } catch (IOException e) {
            throw new RuntimeException("Failed to send error response", e);
        }
    }
}



TokenCheckFilter에는 Access Token을 검증하는 
validateAccessToken() 메소드를 추가하고 
예외 종류에 따라서 AccessTokenException으로 처리합니다.
import io.jsonwebtoken.SignatureException;

...

    public Map<String, Object> validateAccessToken(HttpServletRequest request) throws AccessTokenException {
        String headerStr = request.getHeader("Authorization");

        // 1. Authorization 헤더가 없는 경우
        if (headerStr == null || headerStr.length() < 8) {
            throw new AccessTokenException(AccessTokenException.TOKEN_ERROR.UNACCEPT);
        }

        // 2. 토큰 타입 확인
        String tokenType = headerStr.substring(0, 6);
        String tokenStr = headerStr.substring(7);

        if (!tokenType.equalsIgnoreCase("Bearer")) {
            throw new AccessTokenException(AccessTokenException.TOKEN_ERROR.BADTYPE);
        }

        try {
            // 3. JWT 검증
            Map<String, Object> values = jwtUtil.validateToken(tokenStr);
            return values;

        } catch (MalformedJwtException malformedJwtException) {
            log.error("MalformedJwtException: Invalid token format.");
            throw new AccessTokenException(AccessTokenException.TOKEN_ERROR.MALFORM);

        } catch (SignatureException signatureException) {
            log.error("SignatureException: Invalid token signature.");
            throw new AccessTokenException(AccessTokenException.TOKEN_ERROR.BADSIGN);

        } catch (ExpiredJwtException expiredJwtException) {
            log.error("ExpiredJwtException: Token has expired.");
            throw new AccessTokenException(AccessTokenException.TOKEN_ERROR.EXPIRED);
        }
    }


validateAccessToken()에는 JWTUtil의 
validateToken()을 실행해서 문제가 생기면 발생하는 
JwtException을 이용해서 예외 내용을 출력하고 
AccessTokenException을 던지도록 설계합니다.

TokenCheckFilter에 doFilterInternal()의 내용을 
다음과 같이 수정해서 AcessToken에 문제가 있을 때는 
자동으로 브라우저에 에러 메시지를 상태 코드와 
함께 전송하도록 처리합니다.
...
    try {
            // JWT 유효성 검증
            validateAccessToken(request);

            // 검증 성공 시 다음 필터로 전달
            filterChain.doFilter(request, response);
        } catch (AccessTokenException accessTokenException) {
            // 검증 실패 시 에러 응답 반환
            accessTokenException.sendResponseError(response);
        }
...

TokenCheckFilter에는 아직 모든 기능이 구현되지 않았지만 
적어도 Access Token에 대해서는 파악이 가능하므로 
테스트 환경을 구성하고 이를 확인하도록 합니다.


Swagger UI에서 헤더 처리


Swagger UI는 'Authorization'과 같이 보안과 관련된
헤더를 추가하기 위해서 config 패키지에 SwaggerConfig를 
수정해 주어야 합니다(import할 때 스프링이 아닌
Swagger 관련 API를 이용해야 하므로 주의가 필요합 니다).


import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.bind.annotation.RestController;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spi.service.contexts.SecurityContext;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.ApiKey;
import springfox.documentation.service.AuthorizationScope;
import springfox.documentation.service.SecurityReference;

import java.util.List;

@Configuration
public class SwaggerConfig {

    @Bean
    public Docket api() {
        return new Docket(DocumentationType.OAS_30) // OpenAPI 3.0 사용
                .useDefaultResponseMessages(false) // 기본 응답 메시지 비활성화
                .select()
                .apis(RequestHandlerSelectors.withClassAnnotation(RestController.class)) // RestController가 있는 클래스만 선택
                .paths(PathSelectors.any()) // 모든 경로 포함
                .build()
                .securitySchemes(List.of(apiKey())) // Security 설정 추가
                .securityContexts(List.of(securityContext())) // Security Context 설정 추가
                .apiInfo(apiInfo()); // API 정보 설정
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("Boot API 01 Project Swagger") // 제목
                .description("Swagger 설정을 통한 API 문서화") // 설명
                .version("1.0.0") // 버전
                .build();
    }

    private ApiKey apiKey() {
        // 헤더에서 Authorization을 통해 인증 정보를 전달
        return new ApiKey("Authorization", "Bearer Token", "header");
    }

    private SecurityContext securityContext() {
        return SecurityContext.builder()
                .securityReferences(defaultAuth()) // 인증 정보 참조
                .operationSelector(selector -> selector.requestMappingPattern().startsWith("/api/")) // /api/ 경로에만 SecurityContext 적용
                .build();
    }

    private List<SecurityReference> defaultAuth() {
        AuthorizationScope authorizationScope = new AuthorizationScope("global", "global access");
        return List.of(new SecurityReference("Authorization", new AuthorizationScope[]{authorizationScope}));
    }
}

기존 책 내용 

아래 변경 코드
package com.busanit501.api5012.config;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI openAPI() {

        // Security 설정 추가
        SecurityScheme securityScheme = new SecurityScheme()
                .type(SecurityScheme.Type.HTTP)
                .scheme("bearer")
                .bearerFormat("JWT")
                .name("Authorization");

        return new OpenAPI()
                .info(new Info()
                        .title("레스트 API 테스트")
                        .description("Rest 활용해서 댓글도 구현해보기")
                        .version("1.0.0")
                )
                //추가
                .addSecurityItem(new SecurityRequirement().addList("Authorization"))
                .schemaRequirement("Authorization", securityScheme);
    }

}




변경된 SwaggerConfig에서는 api/' 로 시작하는 경로들에 대해서 
Authorization 헤더를 지정하도록 설정합니다.
앞의 설정이 반영되면 swagger-ui/index.html 에서는 
상단에 [Authorize] 버튼이 생성 되고 Authorization 헤더의 
값을 입력할 수 있는 모달창이 보이게 됩니다.

SwaggerConfig 경로에는 'api/'로 시작하는 경로에서만 
인증 처리가 필요하기 때문에 기존의 
generateToken 에는 영향을 받지 않습니다. 
다음 화면을 보면 '/api/'로 시작하는 Samplecontroller 항목에 
자물쇠가 걸려 있는 것을 확인할 수 있습니다.


• Access Token이 없는 경우

'/api/sample/doA'를 Authorization이 지정되지 않은 상태에서 
호출하면 서버에서는 다 음과 같은 에러 메시지가 전송되게 됩니다.


• 잘못된(Malformed, BadSignatured) Access Token 
화면에서 모달창을 열고 'Bearer 1111'과 같이 
'Bearer'로 시작하는 문자열을 입력하고 [close] 버튼을 눌러 저장합니다.

다시 api/sample/doA'를 호출하면 다음과 같이 
'Malformed Token' 메시지를 확인할 수 있습니다.


• 정상적인 Access Token
만일 정상적인 동작을 확인하고 싶다면 '/files/apilogin.html'의 
실행 결과에서 발행된 Access Token 값을 복사해서 
'Bearer 복사한 문자열'로 다시 저장하고 실행하면 됩니다.

apilogin.html에는 응답된 내용을 쉽게 복사할 수 있도록 
<script> 코드를 수정합니다.
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generate Token</title>
</head>
<body>
<button class="btn1">Generate Token</button>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    // 버튼 클릭 이벤트 처리
    document.querySelector(".btn1").addEventListener("click", () => {
        const data = {
            mid: "apiuser10", // 사용자 ID
            mpw: "11111" // 사용자 비밀번호
        };

        // Axios를 사용하여 POST 요청 보내기
        axios.post("http://localhost:8080/generateToken", data)
            .then(response => {
                // 성공 응답 처리
                console.log("Token generated:", response.data);
                console.log("Token generated:", response.data.accessToken);
                alert("Token: " + response.data.accessToken);
            })
            .catch(error => {
                // 오류 응답 처리
                console.error("Error generating token:", error);
                alert("Error generating token");
            });
    }, false);
</script>
</body>
</html>

예시
스웨거에서 앞에 베어러 설정 되어 있어서 토큰만 붙이고
포스트맨에서는 베어러 설정 확인후 테스트

Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJtaWQiOiJhcGl1c2VyMTAiLCJpYXQiOjE3Mzc4NDYxMTksImV4cCI6MTczNzkzMjUxOX0.5f2qqihjMHrwm11La4gaxGKA7vpvsTzCTiep4wld5zo

브라우저에서 버튼을 클릭하면 다음 화면과 같이 
Access Token이 출력되는 것을 확인하고 
이를 복사해서 테스트에 활용합니다.

Access Token이 정상이라면 다음과 같이 정상적인 결과를 볼 수 있습니다.

• 만료된 Access Token

만료된 Access Token은 예외 메시지의 내용이 
'Expired Token'으로 전송되는 것을 확인 할 수 있습니다.

Refresh Token 처리

만료된 토큰이 전송되는 경우에 사용자는 
다시 서버에 Access Token을 갱신해 달라고 
요구해야 합니다. 
예제에서는 '/refreshToken 이라는 경로를 이용해서 
사용자가 다시 현재의 Access Token과 Refresh Token을 
전송해 주면 이를 처리하도록 구성합니다.


'/refreshToken 에는 주어진 토큰이 다음과 같은 
검증 과정으로 동작하도록 작성합니다.

  Access Token이 존재하는지 확인

  Refresh Token의 만료 여부 확인

  Refresh Token의 만료 기간이 지났다면 
  다시 인증을 통해서 토큰들을 발급받아야 함을 전달
  
Refresh Token을 이용하는 과정에서는 
다음과 같은 상황들이 발생할 수 있습니다.

  Refresh Token의 만료 기간이 충분히 남아 있으므로 
  Access Token만 새로 만들어지는 경우
  
  Refresh Token 자체도 만료 기간이 얼마 
  안 남아서(예제에서는 3일 이내) Acess Token과 
  Refresh Token 모두 새로 만들어야 하는 경우
  
  
RefreshTokenFilter 의 생성

Refresh TokenFilter는 security 패키지 내의 filter
패키지에 추가합니다.

RefreshTokenFilter는 토큰 갱신에 사용할 
경로(/refreshToken)와 JWTUtil을 주입받도록 설계하고, 
해당 경로가 아닌 경우에는 다음 순서의 필터가 실행되도록 구성합니다.

package com.busanit501.api5012.security.filter;

import com.busanit501.api5012.util.JWTUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Log4j2
@RequiredArgsConstructor
public class RefreshTokenFilter extends OncePerRequestFilter {

    private final String refreshPath;
    private final JWTUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        String path = request.getRequestURI();

        // 1. 요청 경로가 refreshPath와 일치하지 않으면 필터 통과
        if (!path.equals(refreshPath)) {
            log.info("Skipping refresh token filter...");
            filterChain.doFilter(request, response);
            return;
        }

        // 2. refreshPath 요청에 대한 처리 로직
        log.info("Refresh Token Filter triggered for path: {}", path);
//
//        try {
//            // 3. Refresh Token 검증 (JWTUtil 사용)
//            String token = extractToken(request);
//            if (token != null) {
//                jwtUtil.validateToken(token); // 토큰 검증
//                log.info("Refresh Token is valid.");
//            } else {
//                log.warn("No Refresh Token found in the request.");
//                response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
//                response.getWriter().write("Missing Refresh Token");
//                return;
//            }
//
//        } catch (Exception e) {
//            log.error("Invalid Refresh Token: {}", e.getMessage());
//            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
//            response.getWriter().write("Invalid Refresh Token");
//            return;
//        }
//
//        // 4. 다음 필터로 전달
//        filterChain.doFilter(request, response);
//    }
//
//    /**
//     * Extracts the token from the Authorization header.
//     */
//    private String extractToken(HttpServletRequest request) {
//        String header = request.getHeader("Authorization");
//        if (header != null && header.startsWith("Bearer ")) {
//            return header.substring(7).trim();
//        }
//        return null;
    }
}



• RefreshToken Filter 설정

RefreshTokenFiter 설정은 CustomSecurityFilter를 
통해서 설정합니다. RefreshTokenFilter는 다른 JWT 관련 
필터들의 동작 이전에 할 수 있도록 TokenCheckFilter 앞으로 배치합니다.



package com.busanit501.api5012.config;

import com.busanit501.api5012.security.APIUserDetailsService;
import com.busanit501.api5012.security.filter.APILoginFilter;
import com.busanit501.api5012.security.filter.RefreshTokenFilter;
import com.busanit501.api5012.security.filter.TokenCheckFilter;
import com.busanit501.api5012.security.handler.APILoginSuccessHandler;
import com.busanit501.api5012.util.JWTUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Log4j2
@Configuration
// 어노테이션을 이용해서, 특정 권한 있는 페이지 접근시, 구분가능.
//@EnableGlobalMethodSecurity(prePostEnabled = true)
// 위 어노테이션 지원중단, 아래 어노테이션 으로 교체, 기본으로 prePostEnabled = true ,
@EnableMethodSecurity
@EnableWebSecurity
@RequiredArgsConstructor
public class CustomSecurityConfig {
    private final APIUserDetailsService apiUserDetailsService;
    //추가,
    private final JWTUtil jwtUtil;

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        log.info("시큐리티 동작 확인 ====webSecurityCustomizer======================");
        return (web) ->
                web.ignoring()
                        .requestMatchers(PathRequest.toStaticResources().atCommonLocations());
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        log.info("===========config=================");

        // AuthenticationManagerBuilder 생성 및 설정
        AuthenticationManagerBuilder authenticationManagerBuilder =
                http.getSharedObject(AuthenticationManagerBuilder.class);

// AuthenticationManagerBuilder에 UserDetailsService와 PasswordEncoder 설정
        authenticationManagerBuilder
                .userDetailsService(apiUserDetailsService) // 사용자 정보를 제공하는 서비스 설정
                .passwordEncoder(passwordEncoder()); // 비밀번호 암호화 방식 설정

// AuthenticationManager 생성
        AuthenticationManager authenticationManager =
                authenticationManagerBuilder.build();

// AuthenticationManager를 HttpSecurity에 설정
        http.authenticationManager(authenticationManager); // 반드시 필요: Security 필터 체인에서 사용할 AuthenticationManager 설정

// APILoginFilter 생성 및 AuthenticationManager 설정
        APILoginFilter apiLoginFilter = new APILoginFilter("/generateToken"); // 로그인 엔드포인트 설정
        apiLoginFilter.setAuthenticationManager(authenticationManager); // APILoginFilter에서 사용할 AuthenticationManager 설정

  // APILoginSuccessHandler 생성: 인증 성공 후 처리 로직을 담당
        // 교체
        APILoginSuccessHandler successHandler = new APILoginSuccessHandler(jwtUtil);

// SuccessHandler 설정: 로그인 성공 시 APILoginSuccessHandler가 호출되도록 설정
        apiLoginFilter.setAuthenticationSuccessHandler(successHandler);

// APILoginFilter를 UsernamePasswordAuthenticationFilter 이전에 추가
        http.addFilterBefore(apiLoginFilter, UsernamePasswordAuthenticationFilter.class); // 사용자 인증 전에 APILoginFilter 동작 설정

        // /api 경로에 대해 TokenCheckFilter 적용
        http.addFilterBefore(
                tokenCheckFilter(jwtUtil),
                UsernamePasswordAuthenticationFilter.class
        );

        // RefreshTokenFilter를 TokenCheckFilter 이전에 등록
        http.addFilterBefore(
                new RefreshTokenFilter("/refreshToken", jwtUtil),
                TokenCheckFilter.class
        );

// CSRF 비활성화
        http.csrf(httpSecurityCsrfConfigurer -> httpSecurityCsrfConfigurer.disable()); // REST API 환경에서 CSRF 보호 비활성화

// 세션 관리 정책 설정
        http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)); // 세션 사용 안 함: JWT 기반 인증 사용

// SecurityFilterChain 반환
        return http.build(); // Security 필터 체인을 빌드하여 반환
    }

    private TokenCheckFilter tokenCheckFilter(JWTUtil jwtUtil) {
        return new TokenCheckFilter(jwtUtil);
    }

}



프로젝트를 실행하고 '/refreshToken' 경로를 호출해서 
서버에서 동작하는지 확인합니다.

화면을 통한 RefreshTokenFilter 확인

RefreshTokenFilter를 호출하는 작업을 좀 더 간단하게 하기 
위해서 html 파일들을 조금 수정해서 테스트가 가능하도록 수정해 봅니다.

우선 apiLogin.html에서는 인증 후에 
전송되는 accessToken과 refreshToken 값을 
Local Storage를 이용해서 저장하 도록 합니다.


Tip
Local Storage는 HTML5의 여러 기능 중 하나로 
브라우저에서 데이터를 보관할 수 있는 기능으로 
쿠 키와 같이 문자열을 보관할 수 있습니다(쿠키의 대체제로 시작되었습니다). 

Local Storage는 window 객체를 통해서 접근할 수 있으며 
settem(키, 값), getltem(키) 메소드를 이용할 수 있습니다.

__
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generate Token</title>
</head>
<body>
<button class="btn1">Generate Token</button>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    // 버튼 클릭 이벤트 처리
    document.querySelector(".btn1").addEventListener("click", () => {
        const data = {
            mid: "apiuser10", // 사용자 ID
            mpw: "11111" // 사용자 비밀번호
        };

        // Axios를 사용하여 POST 요청 보내기
        axios.post("http://localhost:8080/generateToken", data)
            .then(response => {
                // 성공 응답 처리
                console.log("Token generated:", response.data);
                console.log("Token generated:", response.data.accessToken);
                // alert("Token: " + response.data.accessToken);
                // 서버 응답에서 토큰 추출
                const accessToken = response.data.accessToken;
                const refreshToken = response.data.refreshToken;

                // 로컬 스토리지에 토큰 저장
                localStorage.setItem("accessToken", accessToken);
                localStorage.setItem("refreshToken", refreshToken);

                console.log("Access Token and Refresh Token saved to localStorage.");
            })
            .catch(error => {
                // 오류 응답 처리
                console.error("Error generating token:", error);
                alert("Error generating token");
            });
    }, false);
</script>
</body>
</html>


브라우저에서 수정된 apilogin.html을 실행하고 개발자 도구를 
이용해서 'Application' 항목의 Local Storage를 확인해 봅니다.

화면에서 [generate Token] 버튼을 누르면 Local Storage 
안에 토큰들이 저장되는 것을 확인할 수 있습니다.

•'refreshToken 호출하기
토큰들은 브라우저의 Local Storage에 보관되어 있으므 로 
이를 이용해서 '/refreshToken'을 호출하는 화면을 제작 해봅니다. 
static 폴더에 refreshTest.html 파일을 추가합니다.



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Token Refresh Example</title>
</head>
<body>
<h1>ACCESS TOKEN</h1>
<h3 class="accessOld"></h3>
<h3 class="accessResult"></h3>
<hr/>
<h1>REFRESH TOKEN</h1>
<h3 class="refreshOld"></h3>
<h3 class="refreshResult"></h3>
<button class="btn1">Refresh</button>

<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script>
    // 기존 토큰 가져오기
    const oldAccessToken = localStorage.getItem("accessToken");
    const oldRefreshToken = localStorage.getItem("refreshToken");

    // 기존 토큰 화면에 표시
    document.querySelector(".accessOld").innerHTML = oldAccessToken || "No Access Token Found";
    document.querySelector(".refreshOld").innerHTML = oldRefreshToken || "No Refresh Token Found";

    // 버튼 클릭 이벤트 리스너 등록
    document.querySelector(".btn1").addEventListener("click", () => {
        axios
            .post("http://localhost:8080/refreshToken", {
                accessToken: oldAccessToken,
                refreshToken: oldRefreshToken,
            })
            .then((res) => {
                console.log(res.data);

                // 새로운 토큰 받기
                const newAccessToken = res.data.accessToken;
                const newRefreshToken = res.data.refreshToken;

                // 결과 비교 후 화면에 표시
                document.querySelector(".accessResult").innerHTML =
                    oldAccessToken !== newAccessToken ? newAccessToken : "OLD";
                document.querySelector(".refreshResult").innerHTML =
                    oldRefreshToken !== newRefreshToken ? newRefreshToken : "OLD";

                // 새로운 토큰을 로컬 스토리지에 저장
                // localStorage.setItem("accessToken", newAccessToken);
                // localStorage.setItem("refreshToken", newRefreshToken);
            })
            .catch((error) => {
                console.error("Error refreshing tokens:", error);
                alert("Failed to refresh tokens. Please try again.");
            });
    });
</script>
</body>
</html>



refreshTest.html의 내용은 처음에는 Local Storage에 저장되어 있는 
기존의 access Token 과 refresh Token을 화면에 보여줍니다. 
(현재 상황에서 [Refresh] 버튼을 누르면 undefined 만 출력됩니다)

화면에서 [Refresh] 버튼을 누르면 '/refreshToken' 경로를 호출하는데 
이때 기존의 토큰 들은 JSON 데이터로 전송하게 됩니다.

'/refresh Token'의 구현이 완료되면 화면에서 기존의 토큰들 
아래에 새로운 토큰 혹은 기존의 토큰이 출력될 것입니다
(현재 상황에서 [Refresh] 버튼을 누르면 undefined만 출력됩니다).


Refresh Token 구현과 예외 처리

RefreshTokenFilter의 내부 구현은 다음과 같은 순서로 처리됩니다.

1 전송된 JSON 데이터에서 accessToken과 refreshToken을 추출

2 accessToken을 검사해서 토큰이 없거나 잘못된 토큰인 경우 
에러 메시지 전송

3 refreshToken을 검사해서 토큰이 없거나 잘못된 토큰 혹은 
만료된 토큰인 경우 에러 메시지 전송

4 새로운 accessToken 생성

5 만료 기한이 얼마 남지 않은 경우 새로운 refreshToken 생성

6  accessToken과 refreshToken 전송



RefreshTokenException
  
RefreshTokenFilter의 동작 과정 중에서 
여러 종류의 예외 사항이 발생하므로 이를 별도의 
예외 클래스로 분리해 주도록 합니다. 
security/exception 패키지에 
RefreshTokenException 클래스를 추가합니다.

RefreshTokenException 은 AccessTokenException
과 유사하게 토큰들이 없거나 문제있는 경우와 
RefreshToken이 오랜된 경우를 구분해서 사용합니다.


package com.busanit501.api5012.security.exception;

import com.google.gson.Gson;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;


import java.io.IOException;
import java.util.Date;
import java.util.Map;

public class RefreshTokenException extends RuntimeException {

    private final ErrorCase errorCase;

    public enum ErrorCase {
        NO_ACCESS,    // Access Token이 없음
        BAD_ACCESS,   // 잘못된 Access Token
        NO_REFRESH,   // Refresh Token이 없음
        OLD_REFRESH,  // 오래된 Refresh Token
        BAD_REFRESH   // 잘못된 Refresh Token
    }

    // 생성자
    public RefreshTokenException(ErrorCase errorCase) {
        super(errorCase.name());
        this.errorCase = errorCase;
    }

    /**
     * 에러 응답을 HTTP 응답으로 전송
     *
     * @param response HTTP 응답 객체
     */
    public void sendResponseError(HttpServletResponse response) {
        response.setStatus(HttpStatus.UNAUTHORIZED.value()); // HTTP 401 상태 설정
        response.setContentType(MediaType.APPLICATION_JSON_VALUE); // 응답 Content-Type 설정

        Gson gson = new Gson();
        String responseStr = gson.toJson(Map.of(
                "msg", errorCase.name(),    // 에러 메시지
                "time", new Date()          // 현재 시간
        ));

        try {
            response.getWriter().println(responseStr); // JSON 응답 전송
        } catch (IOException e) {
            throw new RuntimeException("Failed to send error response", e);
        }
    }
}




• 토큰 검사
RefreshTokenFilter의 doFilterInternal() 내부에서는 
우선 JSON 데이터들을 처리해서
accessToken과 refreshToken을 확인합니다.

package com.busanit501.api5012.security.filter;

import com.busanit501.api5012.util.JWTUtil;
import com.google.gson.Gson;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.Map;

@Log4j2
@RequiredArgsConstructor
public class RefreshTokenFilter extends OncePerRequestFilter {

    private final String refreshPath;
    private final JWTUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        String path = request.getRequestURI();

        // 1. 요청 경로가 refreshPath와 일치하지 않으면 필터 통과
        if (!path.equals(refreshPath)) {
            log.info("Skipping refresh token filter...");
            filterChain.doFilter(request, response);
            return;
        }

        // 2. refreshPath 요청에 대한 처리 로직
        log.info("Refresh Token Filter triggered for path: {}", path);
// 2. 요청에서 accessToken과 refreshToken 추출
        try {
            Map<String, String> tokens = parseRequestJSON(request);
            if (tokens == null || !tokens.containsKey("accessToken") || !tokens.containsKey("refreshToken")) {
                log.error("Missing tokens in request.");
                response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
                response.getWriter().write("Missing accessToken or refreshToken.");
                return;
            }

            String accessToken = tokens.get("accessToken");
            String refreshToken = tokens.get("refreshToken");

            log.info("accessToken: {}", accessToken);
            log.info("refreshToken: {}", refreshToken);

            // 이후 로직 추가: Refresh Token 검증 및 처리

        } catch (Exception e) {
            log.error("Error parsing request JSON: {}", e.getMessage());
            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            response.getWriter().write("Invalid JSON format.");
            return;
        }

        
    }

    /**
     * 요청에서 JSON 데이터를 Map으로 변환
     */
    private Map<String, String> parseRequestJSON(HttpServletRequest request) {
        try (Reader reader = new InputStreamReader(request.getInputStream())) {
            Gson gson = new Gson();
            return gson.fromJson(reader, Map.class);
        } catch (Exception e) {
            log.error("Error reading JSON from request: {}", e.getMessage());
        }
        return null;
    }
}




브라우저에서 '/fles/refreshTest.html'을 이용해서 
/refreshToken'을 호출하면 서버에서는 
다음과 같이 토큰들을 추출하는 것을 확인할 수 있습니다.

access Token의 검증은 checkAccessToken()이라는 
별도의 메소드로 처리합니다. 
문제가 생기면 RefreshTokenException을 전달합니다. 
Access Token은 만료 기간이 지난 상황은 
당연한 것이므로 로그만 출력해 주도록 합니다.

 private void checkAccessToken(String accessToken) throws RefreshTokenException {
        try {
            // Access Token 검증
            jwtUtil.validateToken(accessToken);
        } catch (ExpiredJwtException expiredJwtException) {
            // Access Token 만료 시 로그 출력
            log.info("Access Token has expired.");
        } catch (Exception exception) {
            // 기타 검증 실패 시 예외 발생
            log.error("Access Token validation failed: {}", exception.getMessage());
            throw new RefreshTokenException(RefreshTokenException.ErrorCase.NO_ACCESS);
        }
    }


doFilterInternal()에서는 예외 발생 시 메시지를 전송하고 
메소드의 실행을 종료합니다.


log.info("accessToken: {}", accessToken);
log.info("refreshToken: {}", refreshToken);

try {
...
    // Access Token 검증
    checkAccessToken(accessToken);
} catch (RefreshTokenException refreshTokenException) {
    // RefreshTokenException 발생 시 응답 에러 전송 및 종료
    refreshTokenException.sendResponseError(response);
    return; // 더 이상 실행하지 않음
}



Refresh Token의 경우도 검사가 필요합니다. 
Refresh Token이 존재하는지와 만료일이 지났는지를 확인하고, 
새로운 토큰 생성을 위해서 mid 값을 얻어두도록 합니다.

RefreshTokenFilter 내부에 checkRefreshToken()을 생성해서 
문제가 생기면 RefreshTokenException을 발생하고, 
정상이라면 토큰 내용물들을 Map으로 반환하도록 구성합니다.

private Map<String, Object> checkRefreshToken(String refreshToken) throws RefreshTokenException {
        try {
            // Refresh Token 검증 및 클레임 데이터 반환
            return jwtUtil.validateToken(refreshToken);

        } catch (ExpiredJwtException expiredJwtException) {
            // Refresh Token이 만료된 경우
            log.error("ExpiredJwtException: Refresh Token has expired.");
            throw new RefreshTokenException(RefreshTokenException.ErrorCase.OLD_REFRESH);

        } catch (MalformedJwtException malformedJwtException) {
            // Refresh Token의 형식이 잘못된 경우
            log.error("MalformedJwtException: Invalid Refresh Token format.");
            throw new RefreshTokenException(RefreshTokenException.ErrorCase.BAD_REFRESH);

        } catch (Exception exception) {
            // 기타 예외 발생 시
            log.error("Unexpected exception during Refresh Token validation: {}", exception.getMessage());
            throw new RefreshTokenException(RefreshTokenException.ErrorCase.NO_REFRESH);
        }
		//return null;
    }


RefreshTokenFilter의 doFilterInternal() 내부에는 
checkRefreshToken()을 처리하는 부 분을 추가합니다.

try {
    // Access Token 검증
    checkAccessToken(accessToken);
} catch (RefreshTokenException refreshTokenException) {
    // Access Token 검증 실패 시 에러 응답 전송
    refreshTokenException.sendResponseError(response);
    return; // 이후 코드 실행 중단
}

Map<String, Object> refreshClaims = null;

try {
    // Refresh Token 검증
    refreshClaims = checkRefreshToken(refreshToken);
    log.info("Refresh Token Claims: {}", refreshClaims);
} catch (RefreshTokenException refreshTokenException) {
    // Refresh Token 검증 실패 시 에러 응답 전송
    refreshTokenException.sendResponseError(response);
    return; // 이후 코드 실행 중단
}

// Refresh Token과 Access Token 검증이 성공하면 이후 로직을 실행
// ...




브라우저를 이용해서 오래된 accessToken과 refreshToken을 
전송해보면 'OLD_RFFRESH'라는 메시지가 전송되는 것을 확인할 수 있습니다.


__
• 새로운 Access Token 발행

토큰들의 검증 단계가 끝났다면 이제 새로운 토큰들을 발행해 주어야 합니다.
  Access Token은 무조건 새로 발행합니다.
  Refresh Token은 만료일이 얼마 남지 않은 경우에 새로 발행합니다.
  
RefreshTokenFilter의 doFilterInternal() 내부에는 
RefreshToken의 내용물(claims)들 을 이용해 
앞의 로직을 구현합니다. 
try 내부에 다음과 같은 코드를 추가합니다.

// Refresh Token 검증
refreshClaims = checkRefreshToken(refreshToken);
log.info("Refresh Claims: {}", refreshClaims);

// Refresh Token 만료 시간 확인
Integer exp = (Integer) refreshClaims.get("exp");
Date expTime = new Date(Instant.ofEpochSecond(exp).toEpochMilli()); // 만료 시간
Date current = new Date(System.currentTimeMillis()); // 현재 시간

// 만료 시간과 현재 시간의 간격 계산
long gapTime = expTime.getTime() - current.getTime();
log.info("Current Time: {}", current);
log.info("Expiration Time: {}", expTime);
log.info("Time Gap: {} milliseconds", gapTime);

// Refresh Claims에서 사용자 ID 추출
String username = (String)refreshClaims.get("mid");
log.info("username: " + username);

// Access Token 재생성
String accessTokenValue = jwtUtil.generateToken(Map.of("username", username), 1);
String refreshTokenValue = tokens.get("refreshToken");

// Refresh Token의 유효 시간이 3일 이하인 경우 새로 생성
if(gapTime < (1000 * 60 * 60 * 24 * 3  ) ){
log.info("new Refresh Token required...  ");
refreshTokenValue = jwtUtil.generateToken(Map.of("username", username), 3);
}
log.info("Refresh Token result....................");
// 로그 출력
log.info("Generated Access Token: {}", accessTokenValue);
log.info("Generated Refresh Token: {}", refreshTokenValue);

// 이후 로직 (예: 응답 반환)
// ...



최종적으로 만들어진 토큰들을 전송하는 sendTokens()를 작성하고 
토큰들을 이용해서 메 시지를 전송합니다.


    private void sendTokens(String accessTokenValue, String refreshTokenValue, HttpServletResponse response) {
        response.setContentType(MediaType.APPLICATION_JSON_VALUE); // 응답 Content-Type 설정

        // JSON 응답 생성
        Gson gson = new Gson();
        String jsonStr = gson.toJson(Map.of(
                "accessToken", accessTokenValue,
                "refreshToken", refreshTokenValue
        ));

        try {
            // 응답 출력
            response.getWriter().println(jsonStr);
        } catch (IOException e) {
            // IOException 발생 시 RuntimeException으로 래핑하여 던짐
            throw new RuntimeException("Failed to send tokens to client", e);
        }
    }


dorilterInternal()의 새로운 토큰들을 생성한 후에 
sendTokens()를 호출합니다.

// 로그 출력: Refresh Token 처리 결과
log.info("Refresh Token result...");

// 로그 출력: Access Token과 Refresh Token 값
log.info("Access Token: {}", accessTokenValue);
log.info("Refresh Token: {}", refreshTokenValue);

// 클라이언트로 토큰 전송
sendTokens(accessTokenValue, refreshTokenValue, response);




•'refreshToken' 확인
브라우저로 '/refreshToken'의 동작을 확인해 봅니다. 
브라우저에서 'apilogin.html'로 새로운 토큰들을 받아 
Local Storage에 저장합니다.

'/files/refreshTest.html'을 이용해서 refreshToken'을 
호출하게 되면 기존의 Access Token 대신에 
새로운 Access Token이 만들어지는 것을 확인할 수 있고, 
Refresh Token은 유효기간에 따라 새로 생성되는 것을 
확인할 수 있습니다.

Refresh Token의 만료일까지 시간이 충분히 남은 경우에
RefreshToken은 새로 발행되지 않습니다.


package com.busanit501.api5012.security.filter;

package com.busanit501.api5012.security.filter;

import com.busanit501.api5012.security.exception.RefreshTokenException;
import com.busanit501.api5012.util.JWTUtil;
import com.google.gson.Gson;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.MalformedJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.http.MediaType;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.time.Instant;
import java.util.Date;
import java.util.Map;

@Log4j2
@RequiredArgsConstructor
public class RefreshTokenFilter extends OncePerRequestFilter {

    private final String refreshPath;
    private final JWTUtil jwtUtil;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {

        String path = request.getRequestURI();

        // 1. 요청 경로가 refreshPath와 일치하지 않으면 필터 통과
        if (!path.equals(refreshPath)) {
            log.info("Skipping refresh token filter...");
            filterChain.doFilter(request, response);
            return;
        }

        // 2. refreshPath 요청에 대한 처리 로직
        log.info("Refresh Token Filter triggered for path: {}", path);
// 2. 요청에서 accessToken과 refreshToken 추출

        //전송된 JSON에서 accessToken과 refreshToken을 얻어온다.
        Map<String, String> tokens = parseRequestJSON(request);

        String accessToken = tokens.get("accessToken");
        String refreshToken = tokens.get("refreshToken");

        log.info("lsy accessToken: " + accessToken);
        log.info("lsy refreshToken: " + refreshToken);

        try {
            // Access Token 검증
            checkAccessToken(accessToken);
        } catch (RefreshTokenException refreshTokenException) {
            // RefreshTokenException 발생 시 응답 에러 전송 및 종료
            refreshTokenException.sendResponseError(response);
            return; // 더 이상 실행하지 않음
        }

        Map<String, Object> refreshClaims = null;

        try {
            // Refresh Token 검증
            refreshClaims = checkRefreshToken(refreshToken);
            log.info("Refresh Token Claims: {}", refreshClaims);
        } catch (RefreshTokenException refreshTokenException) {
            // Refresh Token 검증 실패 시 에러 응답 전송
            refreshTokenException.sendResponseError(response);
            return; // 이후 코드 실행 중단
        }
// Refresh Token 만료 시간 확인
        Integer exp = (Integer) refreshClaims.get("exp");
        Date expTime = new Date(Instant.ofEpochSecond(exp).toEpochMilli()); // 만료 시간
        Date current = new Date(System.currentTimeMillis()); // 현재 시간

// 만료 시간과 현재 시간의 간격 계산
        long gapTime = expTime.getTime() - current.getTime();
        log.info("Current Time: {}", current);
        log.info("Expiration Time: {}", expTime);
        log.info("Time Gap: {} milliseconds", gapTime);

        String username = (String)refreshClaims.get("mid");
        log.info("username: " + username);
        //이상태까지 오면 무조건 AccessToken은 새로 생성
        String accessTokenValue = jwtUtil.generateToken(Map.of("username", username), 1);

        String refreshTokenValue = tokens.get("refreshToken");

        //RefrshToken이 3분도 안남았다면..
//        if(gapTime < (1000 * 60  * 3  ) ){
        //RefrshToken이 3일도 안남았다면..
        if(gapTime < (1000 * 60 * 60 * 24 * 3  ) ){
            log.info("new Refresh Token required...  ");
            refreshTokenValue = jwtUtil.generateToken(Map.of("username", username), 3);
        }

        log.info("Refresh Token result....................");

// 로그 출력
        log.info("Generated Access Token: {}", accessTokenValue);
        log.info("Generated Refresh Token: {}", refreshTokenValue);
// 클라이언트로 토큰 전송
        sendTokens(accessTokenValue, refreshTokenValue, response);
    }

    /**
     * 요청에서 JSON 데이터를 Map으로 변환
     */
    private Map<String, String> parseRequestJSON(HttpServletRequest request) {
        try (Reader reader = new InputStreamReader(request.getInputStream())) {
            Gson gson = new Gson();
            return gson.fromJson(reader, Map.class);
        } catch (Exception e) {
            log.error("Error reading JSON from request: {}", e.getMessage());
        }
        return null;
    }

    private void checkAccessToken(String accessToken) throws RefreshTokenException {
        try {
            // Access Token 검증
            jwtUtil.validateToken(accessToken);
        } catch (ExpiredJwtException expiredJwtException) {
            // Access Token 만료 시 로그 출력
            log.info("Access Token has expired.");
//            throw new RefreshTokenException(RefreshTokenException.ErrorCase.NO_ACCESS);
        } catch (Exception exception) {
            // 기타 검증 실패 시 예외 발생
            log.error("Access Token validation failed: {}", exception.getMessage());
            throw new RefreshTokenException(RefreshTokenException.ErrorCase.NO_ACCESS);
        }
    }

    private Map<String, Object> checkRefreshToken(String refreshToken) throws RefreshTokenException {
        try {
            // Refresh Token 검증 및 클레임 데이터 반환
            return jwtUtil.validateToken(refreshToken);

        } catch (ExpiredJwtException expiredJwtException) {
            // Refresh Token이 만료된 경우
            log.error("ExpiredJwtException: Refresh Token has expired.");
            throw new RefreshTokenException(RefreshTokenException.ErrorCase.OLD_REFRESH);

        } catch (MalformedJwtException malformedJwtException) {
            // Refresh Token의 형식이 잘못된 경우
            log.error("MalformedJwtException: Invalid Refresh Token format.");
            throw new RefreshTokenException(RefreshTokenException.ErrorCase.BAD_REFRESH);

        } catch (Exception exception) {
            // 기타 예외 발생 시
            log.error("Unexpected exception during Refresh Token validation: {}", exception.getMessage());
            throw new RefreshTokenException(RefreshTokenException.ErrorCase.NO_REFRESH);
        }
        //return null;
    }

    private void sendTokens(String accessTokenValue, String refreshTokenValue, HttpServletResponse response) {
        response.setContentType(MediaType.APPLICATION_JSON_VALUE); // 응답 Content-Type 설정

        // JSON 응답 생성
        Gson gson = new Gson();
        String jsonStr = gson.toJson(Map.of("accessToken", accessTokenValue, "refreshToken", refreshTokenValue));

        try {
            // 응답 출력
            response.getWriter().println(jsonStr);
        } catch (IOException e) {
            // IOException 발생 시 RuntimeException으로 래핑하여 던짐
            throw new RuntimeException("Failed to send tokens to client", e);
        }
    }
}





__
JWT의 한계
JWT를 이용해서 자원을 보호하는 방식은 태생적으로 문자열이라는 
한계가 존재합니다. 

예를 들어 
Refresh Token을 이용하는 부분만 생각해 보아도 
외부의 공격자가 Refresh Token을 탈취한 상황이라면 
얼마든지 새로운 Access Token을 생성할 수 있기 때문에 
안전 하지 않습니다.

이런 상황을 조금이라도 보완하기 위해서 Access Token과 
Refresh Token을 데이터베이스에 보관하고 
토큰을 갱신할 때 데이터베이스의 값과 비교하는 방법을 이용할 수 있습니다.

이 경우 정상적인 사용자가 Refresh Token을 갱신하게 되면 
공격자가 탈취한 Refresh Token이 쓸모없게 됩니다.

이런 방식과 유사하게 새로운 Access Token이 발행될 때 
아예 Refresh Token도 새로 발급 하고 데이터베이스에 
이를 저장하는 방법도 있습니다. 

이렇게 되면 탈취된 Refresh Token의 유효 기간이 짧아지기 때문에 
조금 더 안전해지긴 하지만 Access Token과 Refresh Token의 
유효 시간이 같아지게 되므로 원래의 취지와는 조금 다른 형태가 됩니다.

JWT를 안전하게 하기 위한 대부분의 방법들이 근본적으로 공격자가 
Access Token과 Refresh Token을 탈취한 경우 최소한 1회 이상은 
작업이 가능하다는 점에서 모든 보완책이 완벽할 수는 없습니다
(엄밀하게 따지면 인터넷에서 공격자가 사용자의 
아이디와 패스워드를 탈취하는 상황과 큰 차이가 없습니다).

브라우저에서 JWT 확인

API 서버를 이용하는 구조에서는 브라우저에서 
HTTP로 JWT 토큰을 전송하고 
필요한 자원에 접근하는 방식을 이용합니다. 

예제에서는 Access Token과 Refresh Token 등의 
활용을 우선적으로 
같은 서버 환경에서 먼저 체크하고 이후에 
별도의 서버를 구축해서 확인하도록 합니다.


브라우저에서 JWT를 이용하는 시나리오를 
정리하면 다음과 같습니다.


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>
<body>

<h1>Sample HTML </h1>
<h2>http://localhost:8080/sample.html 직접 접근</h2>
<script>

    async function callTest(){
        const response = await axios.get("http://localhost:8080/api/sample/doA")
        return response.data
    }

    callTest()
        .then(data => console.log(data))
        .catch(e => console.log(e));


</script>
</body>
</html>


1단계 당연히 generateToken'을 호출해서 
서버에서 발행한 Access Token과 Refresh Token을 
받는 단계입니다. 
브라우저는 받은 토큰들을 저장해 두고 필요할 때마다 
토큰들을 찾아서 사용하도록 구성해야 합니다.

2단계
브라우저에서 /api/sample/doA'를 호출할 때 가지고 있는 
Access Token을 같이 전달했을 때 정상적인 결과가 
나오는지를 확인합니다.

3 단계 Access Token의 유효 기간이 
만료되는 상황에 대한 처리입니다. 
Access Token의 유효 기간이 만료되면 
서버에서는 에러 메시지를 전송하게 되는데, 
이 메시지를 판단해서 
브라우저는 Refresh Token으로 
다시 새로운 Access Token을 받고 
원래 의도했던 작업을 수행해야 합니다
(이 과정은 사용자가 참여하지 않고 자동으로 처리되어야 하기 
때문에 'slient refreshing 이라고 하기도 합니다).

4 단계 Refresh Token 마저도 만료된 상황에 대한 처리입니다. 
Refresh Token이 만료되면 
새로운 Access Token을 발행할 수 없기 때문에 
사용자에게 1단계부터 다시 시작해야 함을 알려주어야 합니다.

1단계 - 토큰 생성과 저장

1단계는 apilogin.html에서 구현되었습니다.
apiLogin.html에서 생성된 토큰들은 다음 코드를  해서 보관됩니다.

apiLogin.html
     // Axios를 사용하여 POST 요청 보내기
        axios.post("http://localhost:8080/generateToken", data)
            .then(response => {
                // 성공 응답 처리
                console.log("Token generated:", response.data);
                console.log("Token generated:", response.data.accessToken);
                // alert("Token: " + response.data.accessToken);
                // 서버 응답에서 토큰 추출
                const accessToken = response.data.accessToken;
                const refreshToken = response.data.refreshToken;

                // 로컬 스토리지에 토큰 저장
                localStorage.setItem("accessToken", accessToken);
                localStorage.setItem("refreshToken", refreshToken);

                console.log("Access Token and Refresh Token saved to localStorage.");
            })

2단계
- Access Token을 이용한 접근 토큰들을 생성하고 
보관했다면 다른 html에서 이를 이용해서 
서버를 호출해 보도록 합니다. 

static 폴더에 만들어진 sample.html은 
Access Token을 이용하지 않 는 예제이므로 
별도의 sendJWT.html 파일을 추가해서 이를 구현해 보도록 합니다.

sendJWT.html 파일은 Axios 라이브러리를 추가하고 
버튼을 누르면 동작할 수 있도록 구성

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <div class="result"></div>
    <button class="btn1">CALL SERVER</button>

    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script>
        const callServer = async () => {
            console.log("Call server 1....");
            return "Server Response"; // 서버 응답 예제
        };

        const resultDiv = document.querySelector(".result");
        document.querySelector(".btn1").addEventListener("click", async () => {
            try {
                const result = await callServer();
                console.log(result);
                resultDiv.textContent = result; // 결과 출력
            } catch (error) {
                console.error("Error calling server:", error);
            }
        });
    </script>
</body>
</html>


브라우저를 통해서 '/files/sendJWT.html'을 실행하고 
버튼을 눌렀을 때 다음과 같이 동작하는지 확인합니다.

callServer() 함수 내부에서는 Local Storage에 보관된 
Access Token을 이용하도록 수정 합니다. 
만일 Access Token이 없다면 경고창을 통해서 
알 수 있게 예외를 발생하도록 구성합 니다.

<script>
const callServer = async () => {
    console.log("Call server 1...");
    
    const accessToken = localStorage.getItem("accessToken");
    if (!accessToken) {
        throw new Error("Cannot Find Access Token");
    }

    return `Server called with token: ${accessToken}`;
};

const resultDiv = document.querySelector(".result");

document.querySelector(".btn1").addEventListener("click", async () => {
    try {
        const result = await callServer();
        console.log(result);
        resultDiv.textContent = result; // 결과 화면에 표시
    } catch (error) {
        alert(error.message); // 오류 메시지 경고창으로 출력
    }
});
</script>



브라우저에 토큰들이 없도록 Local Storage를 지운 상태에서 
버튼을 누르면 'Cannot Find Access Token 에러가 발생하게 됩니다.

만일 Access Token이 존재한다면 
'api/sample/doA'를 호출하도록 코드를 수정합니다.

Access Token은 HTTP의 'Authorziation' 헤더로 
전송해야 하므로 다음과 같이 작성합 니다.

const callServer = async() => {
        console.log("call server 1...")

        const accessToken = localStorage.getItem("accessToken")

        if(!accessToken) {
            throw 'Cannot Find Access Token'
        }

        const authHeader = {"Authorization": `Bearer ${accessToken}`}
   
            const res = await axios.get("http://localhost:8080/api/sample/doA",
                {headers: authHeader})
            return res.data

유효한 Access Token이 전달되면 다음과 같이 서버를 호출하고 
send.JWT.html까지 전달 되는 결과를 확인할 수 있습니다
(Access Token의 만료 기한이 충분한 경우라면).


만일 Access Token이 없다면 다음과 같은 객체가 전달됩니다.

accessToken null error
• {ERROR: 'Access Token is null'}

만일 Acces Token이 잘못되었다면 API 서버에서 
TokenCheck Filter가 생성해 내는 예외 객체를 받게 됩니다. 
다음과 같은 화면은 고의로 브라우저에 
Access Token의 마지막에 이상 한 문자열을 추가해서 
SignatureException이 발생하도록 한 경우입니다.

• 3단계- Refresh 처리
만료일이 지난 Access Token을 전송하게 되면 
현재 코드의 sendJWT.html에서 403 예외 가 발생하게 됩니다.

서버를 호출할 때 'Expired Token' 예외가 전달되면 
별도의 처리가 필요하므로 예외 관련 된 코드를 추가합니다.

<script>

    const callServer = async() => {
        console.log("call server 1...")

        const accessToken = localStorage.getItem("accessToken")

        if(!accessToken) {
            throw 'Cannot Find Access Token'
        }

        const authHeader = {"Authorization": `Bearer ${accessToken}`}
        try {
            const res = await axios.get("http://localhost:8080/api/sample/doA",
                {headers: authHeader})
            return res.data
        }catch(err) {

            if(err.response.data.msg === 'Expired Token'){
                console.log("Refresh Your Token")

변경된 코드를 실행하고 'Acces Token' 이 만료된 경우에는 다음과 같은 
메세지가 보이게 됨. 
'Expired Token' 메세지가 발생하는 경우에 반드시 한번은 
'refreshToken'을 호출하도록 수정함. 
'/refreshToken'을 호출하는 함수를 추가하고 예외 발생 시에 
호출하도록 함. 

<script>

    const callServer = async() => {
        console.log("call server 1...")

        const accessToken = localStorage.getItem("accessToken")

        if(!accessToken) {
            throw 'Cannot Find Access Token'
        }

        const authHeader = {"Authorization": `Bearer ${accessToken}`}
        try {
            const res = await axios.get("http://localhost:8080/api/sample/doA",
                {headers: authHeader})
            return res.data
        }catch(err) {

            if(err.response.data.msg === 'Expired Token'){
                console.log("Refresh Your Token")

                try{
                    await callRefresh()
                    console.log("new tokens....saved..")
                    return callServer()

                }catch(refreshErr){
                    throw refreshErr.response.data.msg
                }
            }//end if
        }
    }

    const callRefresh = async () => {

        const accessToken = localStorage.getItem("accessToken")
        const refreshToken = localStorage.getItem("refreshToken")

        const tokens = {accessToken, refreshToken}
        const res = await axios.post("http://localhost:8080/refreshToken", tokens)
        localStorage.setItem("accessToken", res.data.accessToken)
        localStorage.setItem("refreshToken", res.data.refreshToken)
    }


    const resultDiv = document.querySelector(".result")

    document.querySelector(".btn1").addEventListener("click", () => {

        callServer().then(result => {
            console.log(result)
        }).catch(error => {
            alert(error)
        })
    },false)

</script>


추가된 callRefresh()는 'Expired Token' 메시지가 전송되면 
기존의 토큰들을 전송해서 새로운 'Access Token'을 받아 다시 
Local Storage에 저장합니다. 
저장된 후에 원래의 함수를 다시 호출해서 정상적으로 
호출되는지 확인할 수 있습니다.

앞의 실행 결과를 보면 'api/sample/doA'를 호출했을 때 
오래된 Access Token을 가지고 접근했기 때문에 
Refresh Token을 이용해서 토큰을 갱신하고 저장한 후에 
다시 '/api/sample/doA'를 호출한 결과를 반환하고 있습니다.

• 4단계 - 만료된 Refresh Token
만일 Access Token과 Refresh Token이 모두 만료된 상황이라면 
브라우저에서는 'OLD-REFRESH' 에러 메시지가 전송됩니다.

__
Ajax와 CORS 설정
API 서버에서는 JSON 데이터만 주고받는 방식이기 때문에 실제로 
화면이 존재하지 않습니다. 

실제 화면은 별도의 서버를 이용해서 처리하거나 리액트, Vue.js 등을 
이용하는 SPA (Single Page Application) 방식으로 구현해서 
물리적으로 분리되어 있는 서버나 프로그램에서 Ajax로 호출하게 됩니다.

이처럼 다른 서버에서 Ajax를 호출하면 
'동일 출처 정책(same-origin policy)'을 위반하게 되면서 
Ajax 호출은 정상적으로 이루어지지 않습니다. 

'동일 출처 정책'은 웹 브라우저 보안을 위해 
프로토콜, 호스트, 포트가 같은 서버로만 ajax 요청을 주고 받을 수 있도록 
한 정책으로 Ajax를 이용해서 
다른 서버의 자원들을 마음대로 사용하는 것을 막기 위한 보안 조치입 니다.

Ajax 호출이 '동일 출처 정책'으로 인해서 제한 받기 때문에 
이를 해결하려면 'CORS (Cross Origin Resosource Sharing)' 
처리가 필요합니다. 

CORS 처리를 하게 되면 Ajax 호출 서버와 API 서버가 다른 경우에도 
접근과 처리를 허용할 수 있습니다.

CORS 처리가 필요한 상태 확인
실제로 어떤 문제가 있는지 확인하기 위해서 현재의 프로젝트가 
실행되는 환경(API 서버)에서 다른 포트로 별도의 서버(웹 서버)를 구성하고 
어떤 문제가 생기는지 확인해 보도록 합니다. 

작성하려는 새로운 프로젝트는 현재 실행되고 있는 API 서버가 
실행되는 상황에서 추가로 프로젝트를 구성하는 방식입니다.

Nginx 웹 서버의 설치
별도의 서버를 구성하려는 방법은 여러가지가 있을 수 있지만 
최근에 많이 사용되는 Nginx 서버를 세팅해서 html 파일들을
서비스하고 Ajax를 이용해서 JWT를 사용해 보도록 합니다.

Nginx의 설치는 https://nginx.org/en/download.html 에서 
오픈소스로 제공되는 웹 서버 를 내려받을 수 있습니다.

윈도우를 이용하는 경우 목록 중간 Stable version에 'Windows'가 
있는 링크를 이용해서 내려받도록 합니다.

C 드라이브 아래에 webserver 폴더를 생성하고 
내려받은 nginx 파일의 압축을 풀어줍니다.

압축을 풀어둔 경로에는 nginx-xxx 폴더가 생성되고 
내부에 폴더와 파일이 생성된 것을 확인할 수 있습니다.

• Nginx의 시작과 종료
폴더들 중에서 html 폴더를 살펴보면 내부에 index.
html과 50x.html이 존재하는 것을 볼 수 있습니다.
Nginx가 시작되면 80 포트를 기본으로 동작하는데

이때 가장 먼저 사용할 수 있는 파일이 index.html입니다.
Nginx의 시작과 종료는 해당 폴더에서 'nginx.exe' 파일을 이용해서 처리합니다.

명령 프롬프트를 이용해서 해당 폴더로 이동하고 
'start nginx'를 이용해서 서버를 실행합니다. 

서버 실행 후에는 브라우저로 http://localhost'를 호출해서 
index.html이 서비스 되는 것을 확인합니다.

서버의 종료는 'nginx -s quit'으로 실행합니다.

• html 폴더 편집
실제 HTML 파일들의 내용은 html 폴더에 위치하므로 
예제에서 작성했던 파일들을 html
폴더에 넣고 편집할 필요가 있습니다
(예제에서는 VSCode를 이용해서 폴더를 열고 작업했 습니다).

예제 파일 동작 확인
인텔리제이 예제 내에 static 폴더의 내용을 복사해서 
html 폴더로 이동시킵니다.

Nginx 서버를 실행하고 http://localhost/apiLogin.html을 실행해서 
generate Token] 버튼을 누르면 문제가 발생하는 것을 볼 수 있습니다.

발생하는 문제는 Ajax 호출에 사용하는 CORS 문제와 
GET 방식이 아닌 POST 방식을 이용할 때 발생하는 Prefight 문제입니다.

Tip
Preflight 요청(사전 요청)
Ajax는 GET/POST/HEAD 방식의 요청을 'Simple Request'라고 하고, 

여기에 서버로 전송하는 Content-Type
application/x-www-form-urlencoded, 
multipart/form-data, text/plain인 경우에는 Ajax의 호출을 허용합니다.

반면 현재 예제와 같이 '커스텀 헤더'를 이용하거나 
Content-Type이 다른 경우에는 'Preflight Request라는 것을 실행합니다.

CORS 문제 해결
Ajax의 동일 출처 정책'을 해결하는 방법에는 여러 가지 방식이 있습니다. 

예를 들어 
브라우저에서 직접 서버를 호출하는 대신에 
현재 서버 내 다른 프로그램을 이용해서 API 서버를 호출하는 
프록시(proxy- 대리자) 패턴을 이용하거나 

JSONP와 같이 JSON이 아니라 순수한 JS 파일을 요청하는 방식 등이 있습니다.

가장 권장되는 해결책은 당연히 서버에서 CORS 관련 설정으로 해결하는 것입니다. 

서버 에서 CORS 설정은 주로 필터(Filter)를 이용해서 
브라우저의 응답 메시지에 해당 호출이 문제 없었다는 헤더 정보들을 같이 
전송하는 방식입니다. 

스프링 부트는 이러한 상황을 처리하기 위해서 
웹 관련 설정을 약간 조정하는 방식을 이용하거나 

컨트롤러는 @CrossOrigin 어노테이션을 이용해서 처리할 수 있습니다. 

스프링 시큐리티 필터들의 설정은 config 폴더의 
CustomSecuityConfig에 설정을 추가하는 방식으로 작성 해봅니다.

• CustomSecurityConfig 수정

프로젝트에서 config 내 CustomSecurityConfig에 
cors() 관련 설정을 객체로 생성하고 

이를 HttpSecurity 객체에 반영합니다
(다음 코드를 작성할 때 import는 org.springframe-work.web.cors로 
시작하는 타입들을 사용합니다).

@Bean
public SecurityFilterChain filterChain(final HttpSecurity http) throws Exception {

log. info("--
---configure--
=-"）；
. . . 생략. . .
 http.cors(httpSecurityCorsConfigurer -> 
        httpSecurityCorsConfigurer.configurationSource(corsConfigurationSource())
    );
   return http.build();
}

@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    configuration.setAllowedOriginPatterns(Arrays.asList("*"));
    configuration.setAllowedMethods(Arrays.asList("HEAD", "GET", "POST", "PUT", "DELETE"));
    configuration.setAllowedHeaders(Arrays.asList("Authorization", "Cache-Control", "Content-Type"));
    configuration.setAllowCredentials(true);

    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", configuration);
    return source;
}

프로젝트를 재시작하고 Nginx 서버의 apiLogin.html을 이용해서 
API 서버의 generateToken'을 호출했을 때 정상적으로 호출되는지 확인합니다.

마지막으로 정상적인 토큰들이 발행되었다면 
'sendJWT.html'을 이용해서 정상으로 
호출이 가능한지 살펴봅니다. 

만일 Refresh Token이 만료되었다면 다음 그림과 같이
 'refreshToken 의 호출도 같이 확인할 수 있습니다.


Todo API 서비스
Ajax로 JSON 데이터를 교환하고 JWT로 인증 정보를 처리할 수 있게 
되었다면 이를 활용하는 간단한 Todo 서비스를 작성해 보도록 합니다.

Todo 서비스는 다음과 같은 경로와 메소드를 이용하도록 구성합니다. 
모든 경로의 호출에 는 JWT를 이용하도록 합니다.

Todo API 서비스 
경로, 메소드, 파라미터, 설명. 
/api/todo/ , post , JSON, 신규 Todo 입력 
/api/todo/list , get, size,page,from,to,keyword, PageResponseDTO를 
JSON으로 만든 결과 
/api/todo/{tno}, get, 특정 Todo 조회 
/api/todo/{tno}, put, JSON, 특정 Todo 수정. 
/api/todo/{tno}, delete, , 특정 Todo 삭제. 


Todo 엔티티/DTO와 Repository
Todo API 서비스는 검색 기능과 페이징 처리 등을 지원하기 위해서 
가장 먼저 도메인 관련 처리를 작성하도록 합니다.

• build. gradle의 Querydsi 설정
build gradlle 파일에 Querydsl을 이용할 수 있는 설정을 추가합니다.

//  설치3번, 순서1 Querydsl 사용하기 위한 변수 설정.
buildscript {
    ext {
        queryDslVersion = "5.0.0"
    }
}

dependencies {
...
  //3, 순서2 Querydsl 이용해서, 동적 sql 다루고, 빌드 패턴이용하고, 자바의 컴파일러 문법 체크 도움도 받기.
    implementation "com.querydsl:querydsl-jpa:${queryDslVersion}:jakarta"

    // 4, 순서4 Querydsl 설정.
    annotationProcessor(
            "jakarta.persistence:jakarta.persistence-api",
            "jakarta.annotation:jakarta.annotation-api",
            "com.querydsl:querydsl-apt:${queryDslVersion}:jakarta"
    )
	...
// Querydsl  설치, 순서3 프로젝트를 빌드 할 때마다, 해당 Q 도메인을 소스로 등록하는 과정을, 자동으로
sourceSets {

    main {
        java {
            srcDirs = ["$projectDir/src/main/java", "$projectDir/build/generated"]
        }
    }
}

compileJava.dependsOn('clean')


•Todo 엔티티 클래스
Todo 엔티티는 domain 패키지에 Todo 클래스로 작성합니다.

package com.busanit501.api5012.domain;

import jakarta.persistence.*;
import lombok.*;
import java.time.LocalDate;

@Entity
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Getter
@ToString
@Table(name = "tbl_todo_api") // 공백 제거
public class Todo {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long tno;

    private String title;
    private LocalDate dueDate;
    private String writer;
    private boolean complete;

    public void changeComplete(boolean complete) {
        this.complete = complete;
    }

    public void changeDueDate(LocalDate dueDate) {
        this.dueDate = dueDate;
    }

    public void changeTitle(String title) { // 메서드 오류 수정
        this.title = title;
    }
}




작성된 Todo에 대해서 Querydsl이 사용하는 QTodo가 
생성되는지를 확인하도록 합니다.
gradle 메뉴의 other에 complileJava를 실행하고 
build 폴더에 생성된 결과를 확인합니다.


•TodoRepository와 테스트
reepository 패키지에 TodoRepository 인터페이스를 추가합니다.


package com.busanit501.api5012.repository;

import com.busanit501.api5012.domain.Todo;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TodoRepository extends JpaRepository<Todo, Long> {
}


테스트 폴더에는 TodoRepositoryTests를 추가합니다.
테스트 코드를 이용해서 100여개의 더미 데이터를 추가하도록 합니다.

package com.busanit501.api5012.repository;

import com.busanit501.api5012.domain.Todo;
import lombok.extern.log4j.Log4j2;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.time.LocalDate;
import java.util.stream.IntStream;

@SpringBootTest
@Log4j2
public class TodoRepositoryTests {

    @Autowired
    private TodoRepository todoRepository;

    @Test
    public void testInsert() {
        IntStream.rangeClosed(1, 100).forEach(i -> {
            Todo todo = Todo.builder()
                    .title("Todo..." + i)
                    .dueDate(LocalDate.of(2022, (i % 12) + 1, (i % 28) + 1)) // 일(day) 값 수정
                    .writer("user" + (i % 10))
                    .complete(false)
                    .build();

            todoRepository.save(todo);
            log.info("Inserted: " + todo);
        });
    }
}


데이터베이스에 추가된 결과를 확인합니다.


• TodoDTO 클래스
dto 패키지에는 Todo를 위한 TodoDTO 를 작성합니다.

package com.busanit501.api5012.dto;

import com.fasterxml.jackson.annotation.JsonFormat;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDate;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class TodoDTO {

    private Long tno;
    private String title; // 'titLe' → 'title' 수정

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd", timezone = "Asia/Seoul")
    private LocalDate dueDate;

    private String writer;
    private boolean complete;
}

TodoDTO는 LocalDate와 boolean을 이용하기 때문에 
JSON 처리 시에 주의할 필요가 있습니다.


TodoService/TodoServicelmpl

서비스 계층은 service 패키지를 생성하고, 
TodoService 인터페이스와 
TodoServiceImpl 클래스만 작성해 두고 
우선 등록에 대한 처리만을 구현하도록 합니다.

package com.busanit501.api5012.service;

import com.busanit501.api5012.dto.TodoDTO;
import org.springframework.transaction.annotation.Transactional;

@Transactional
public interface TodoService {
    Long register(TodoDTO todoDTO);
}


package com.busanit501.api5012.service;

import com.busanit501.api5012.domain.Todo;
import com.busanit501.api5012.dto.TodoDTO;
import com.busanit501.api5012.repository.TodoRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
@Log4j2
public class TodoServiceImpl implements TodoService {

    private final TodoRepository todoRepository;
    private final ModelMapper modelMapper;

    @Override
    @Transactional
    public Long register(TodoDTO todoDTO) {
        Todo todo = modelMapper.map(todoDTO, Todo.class); // 오타 수정
        Long tno = todoRepository.save(todo).getTno(); // getTno() 오타 수정
        return tno;
    }
}



TodoController 처리

controller 패키지에는 TodoController 
클래스를 추가하는데 API 서비스의 경우에는
@RestController를 이용해서 데이터를 처리하도록 구성합니다.

package com.busanit501.api5012.controller;

import com.busanit501.api5012.dto.TodoDTO;
import com.busanit501.api5012.service.TodoService;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/todo")
@Log4j2
@RequiredArgsConstructor
public class TodoController {

    private final TodoService todoService;

    @PostMapping(value = "/", consumes = MediaType.APPLICATION_JSON_VALUE)
    public Map<String, Long> register(@RequestBody TodoDTO todoDTO) {
        log.info("Received Todo: {}", todoDTO);

        // 실제로 todoService.register(todoDTO)를 호출하여 저장된 tno를 반환하도록 수정
        Long tno = todoService.register(todoDTO);
        return Map.of("tno", tno);
    }
}



TodoController는 우선 JSON 문자열을 TodoDTO로 문제없이 
받아들이는지를 먼저 확인하도록 합니다.

프로젝트를 시작하고 Swagger-UI를 이용해서 확인합니다. 
이 과정에서 Access Token이 필요하므로 
미리 '/fles/apiLogin.html'을 이용해서 생성하고 이를 복사해서 사용합니다.

JSON으로 전송된 데이터가 정상적으로 서버에 도달했는지 확인합니다.


앞에서 같이 JSON 문자열의 처리가 문제가 없는지 확인했다면 
Todaervice의 register()
를 이용해서 결과를 만들어 냅니다.

 @PostMapping(value = "/", consumes = MediaType.APPLICATION_JSON_VALUE)
    public Map<String, Long> register(@RequestBody TodoDTO todoDTO) {
        log.info("Received Todo: {}", todoDTO);

        // 실제로 todoService.register(todoDTO)를 호출하여 저장된 tno를 반환하도록 수정
        Long tno = todoService.register(todoDTO);
        return Map.of("tno", tno);
    }
	
	
	

Swagger UI를 이용해서 최종적인 테스트를 진행합니다.

{
  "title": "string",
  "dueDate": "2025-01-31",
  "writer": "string"
}



조회와 목록 처리


조회는 서비스 계층에서 Todo 엔티티 객체를 
TodoDTO로 변환해서 처리하도록 구성합니다.

public interface TodoService {
   Long register(TodoDTO todoDTO);
    TodoDTO read(Long tno);
}

TodoServicelmpl에서의 구현은 다음과 같습니다.

   @Override
    public TodoDTO read(Long tno) {
        Optional<Todo> result = todoRepository.findById(tno);
        Todo todo = result.orElseThrow(); // 예외 발생 시 자동으로 NoSuchElementException 던짐
        return modelMapper.map(todo, TodoDTO.class);
    }


TodoController에서는 @PathVariable을 이용해서 
'api/todo/111'과 같은 경로를 처리합니다.

  @GetMapping("/{tno}") // 경로 수정 (불필요한 공백 제거)
    public TodoDTO read(@PathVariable("tno") Long tno) {
        log.info("read tno: {}", tno);
        return todoService.read(tno);
    }
	
	


GET 방식이지만 API 서비스이므로 Access Token을 지정해야만 
정상으로 동작합니다.



• 페이징 처리를 위한 준비

목록을 처리하기 위해서는 이전 예제에서 작성했던 
PageReguestDTO와 PageResponseDTO를 이용하는 것이 편리합니다.

dto 패키지에 PageRequestDTO 와 PageResponseDTO 
클래스를 추가해 둔 상태에서 개발을 시작합니다.

PageRequestDTO는 Todo의 검색 조건을 고려해서 
다음과 같은 항목들을 추가합니다.

기간별 검색 조건을 고려해서 LocalDate로 from,to
완료 여부를 고려해서 complete
  
package com.busanit501.api5012.dto;

import lombok.*;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.time.LocalDate;

@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
public class PageRequestDTO {

    @Builder.Default
    private int page = 1;

    @Builder.Default
    private int size = 10;

    private String type; // 검색 종류 (T, C, W, TC, TWC 등)
    private String keyword;

    // 추가된 내용들
    private LocalDate from;
    private LocalDate to;
    private Boolean completed;

    public String[] getTypes() {
        if (type == null || type.isEmpty()) {
            return new String[]{};
        }
        return type.split(""); // 한 글자씩 분리
    }

    public Pageable getPageable(String... props) {
        return PageRequest.of(this.page - 1, this.size, Sort.by(props).descending());
    }

    private String link;

    public String getLink() {
        if (link == null) {
            StringBuilder builder = new StringBuilder();
            builder.append("page=").append(this.page);
            builder.append("&size=").append(this.size);

            if (type != null && !type.isEmpty()) {
                builder.append("&type=").append(type);
            }

            if (keyword != null) {
                try {
                    builder.append("&keyword=").append(URLEncoder.encode(keyword, "UTF-8"));
                } catch (UnsupportedEncodingException e) {
                    throw new RuntimeException("Encoding error", e);
                }
            }
            link = builder.toString();
        }
        return link;
    }
}





PageResponseDTO는 기존의 코드를 그대로 사용합니다.

package com.busanit501.api5012.dto;

import lombok.Builder;
import lombok.Getter;
import lombok.ToString;

import java.util.List;

@Getter
@ToString
public class PageResponseDTO<E> {

    private int page;
    private int size;
    private int total;

    // 시작 페이지 번호
    private int start;

    // 끝 페이지 번호
    private int end;

    // 이전 페이지 존재 여부
    private boolean prev;

    // 다음 페이지 존재 여부
    private boolean next;

    private List<E> dtoList;

    @Builder(builderMethodName = "withAll")
    public PageResponseDTO(PageRequestDTO pageRequestDTO, List<E> dtoList, int total) {
        if (total <= 0) {
            return;
        }

        this.page = pageRequestDTO.getPage();
        this.size = pageRequestDTO.getSize();
        this.total = total;
        this.dtoList = dtoList;

        this.end = (int) (Math.ceil(this.page / 10.0)) * 10;
        this.start = this.end - 9;

        int last = (int) (Math.ceil((total / (double) size)));
        this.end = Math.min(end, last); // 마지막 페이지 번호 조정

        this.prev = this.start > 1;
        this.next = total > this.end * this.size;
    }
}



• Querydsl을 이용한 검색 조건 처리
PageRequestDTO의 내용을 고려해서 검색 조건에 따라 
동적으로 검색 조건이 만들어지므로 Querydsl을 이용하기 위해서 
추가적인 개발을 준비합니다.

repositoty 패키지에 search 패키지를 추가하고 
TodoSearch 인터페이스와 TodoSearchImpl(클래스 이름 주의)클래스를 
작성합니다.

public interface TodoSearch {
    Page<TodoDTO> list(PageRequestDTO pageRequestDTO);
}

TodoSearchimpl은 QuerydslRepositorySupport를 
부모 클래스로 지정하고 TodoSearch
인터페이스를 구현하도록 선언합니다.

package com.busanit501.api5012.repository.search;

import com.busanit501.api5012.domain.Todo;
import com.busanit501.api5012.dto.PageRequestDTO;
import com.busanit501.api5012.dto.TodoDTO;
import lombok.extern.log4j.Log4j2;
import org.springframework.data.domain.Page;
import org.springframework.data.jpa.repository.support.QuerydslRepositorySupport;

@Log4j2
public class TodoSearchImpl extends QuerydslRepositorySupport implements TodoSearch {

    public TodoSearchImpl() {
        super(Todo.class);
    }

    @Override
    public Page<TodoDTO> list(PageRequestDTO pageRequestDTO) {
        return null;
    }
}



기존의 TodoRepository에는 TodoSearch 인터페이스를 추가합니다.

package com.busanit501.api5012.repository;

import com.busanit501.api5012.domain.Todo;
import com.busanit501.api5012.repository.search.TodoSearch;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface TodoRepository extends JpaRepository<Todo, Long>, TodoSearch {
}


TodoSearchImpl에는 QTodo를 이용해서 from,to를 이용하는 
검색 조건이나 complete에 해당하는 검색 조건을 다음과 같이 구현합니다.



@Override
public Page<TodoDTO> list(PageRequestDTO pageRequestDTO) {
    QTodo todo = QTodo.todo;
    JPQLQuery<Todo> query = from(todo);

    // 기간 조건 추가
    if (pageRequestDTO.getFrom() != null && pageRequestDTO.getTo() != null) {
        BooleanBuilder fromToBuilder = new BooleanBuilder();
        fromToBuilder.and(todo.dueDate.goe(pageRequestDTO.getFrom()));
        fromToBuilder.and(todo.dueDate.loe(pageRequestDTO.getTo()));
        query.where(fromToBuilder);
    }

    // 완료 여부 조건 추가
    if (pageRequestDTO.getCompleted() != null) {
        query.where(todo.complete.eq(pageRequestDTO.getCompleted()));
    }

    // 키워드 조건 추가 (제목에 포함 여부)
    if (pageRequestDTO.getKeyword() != null) {
        query.where(todo.title.contains(pageRequestDTO.getKeyword()));
    }

    // 페이징 적용 (정렬 기준을 "tno"로 지정)
    this.getQuerydsl().applyPagination(pageRequestDTO.getPageable("tno"), query);

    // Todo 엔티티를 TodoDTO로 변환
    JPQLQuery<TodoDTO> dtoQuery = query.select(Projections.bean(
            TodoDTO.class,
            todo.tno,
            todo.title,
            todo.dueDate,
            todo.complete,
            todo.writer
    ));

    List<TodoDTO> list = dtoQuery.fetch();
    Long count = dtoQuery.fetchCount();

    return new PageImpl<>(list, pageRequestDTO.getPageable("tno"), count);
}



검색 조건에 대한 테스트는 TodoRepositoryTests 를 이용해서 작성합니다.

@Test
public void testSearch() {
    PageRequestDTO pageRequestDTO = PageRequestDTO.builder()
            .from(LocalDate.of(2022, 10, 1))
            .to(LocalDate.of(2022, 12, 31))
            .build();

    Page<TodoDTO> result = todoRepository.list(pageRequestDTO);
    result.forEach(todoDTO -> log.info(todoDTO.toString()));
}



testSearch()를 실행하면 다음과 같이 Todo의 dueDate를 
기준으로 쿼리가 작성되는 것 을 확인할 수 있습니다
(count 쿼리 결과는 생략).


• 서비스 계층 구현
TodoService와 TodoServiceInpl에서는 
TodoRepository의 Page<TodoDTO>를 PageResponseDTO 
타입 으로 변환합니다.

public interface Todoservice {
Long register (TodoDTO todoDTO);
TodoDTO read(Long tno);
PageResponseDTO<TodoDTO> list(PageRequestDTO pageRequestDTO);
｝


TodoServiceImpl 구현은 다음과 같습니다.

@Override
public PageResponseDTO<TodoDTO> list(PageRequestDTO pageRequestDTO) {
    Page<TodoDTO> result = todoRepository.list(pageRequestDTO);
    return PageResponseDTO.<TodoDTO>withAll()
            .pageRequestDTO(pageRequestDTO)
            .dtoList(result.toList())
            .total((int) result.getTotalElements())
            .build();
}




• 컨트롤러 구현과 확인
TodoController에서는 list() 메소드를 
작성해서 검색과 페이징을 처리합니다.

@GetMapping(value = "/list", produces = MediaType.APPLICATION_JSON_VALUE)
public PageResponseDTO<TodoDTO> list(PageRequestDTO pageRequestDTO) {
    return todoService.list(pageRequestDTO);
}



Swagger UI에서는 Access Token을 지정한 후에 확인 가능합니다.


{
  "page": 1,
  "size": 10,
  "type": "c",
  "keyword": "t"

}


Todo 수정과 삭제
Todo 삭제와 달리 수정 가능한 부분은 '제목(title), 
완료 여부(complete), 만료일(due-Date)만 가능합니다.

TodoService와 TodoServicelmpl에서는 수정과 삭제 
기능을 다음과 같이 구현합니다

public interface TodoService {
Long register(TodoDTO todoDTO);
TodoDTO read (Long tno);
PageResponseDTO<TodoDTO› list(PageRequestDTO pageRequestDTO);
void remove(Long tno);
void modify(TodoDTO todoDTO);
}


 @Override
    public void remove(Long tno) {
        todoRepository.deleteById(tno);
    }

    @Override
    public void modify(TodoDTO todoDTO) {
        Optional<Todo> result = todoRepository.findById(todoDTO.getTno());
        Todo todo = result.orElseThrow();
        
        todo.changeTitle(todoDTO.getTitle());
        todo.changeDueDate(todoDTO.getDueDate());
        todo.changeComplete(todoDTO.isComplete());
        
        todoRepository.save(todo);
    }

• 컨트롤러에서의 수정/삭제
TodoController에서 삭제는 Delete 방식으로 처리하고, 
수 정은 PUT 방식으로 처리하도록 구현합니다.


@DeleteMapping(value = "/{tno}")
public Map<String, String> delete(@PathVariable Long tno) {
    todoService.remove(tno);
    return Map.of("result", "success");
}

@PutMapping(value = "/{tno}", consumes = MediaType.APPLICATION_JSON_VALUE)
public Map<String, String> modify(@PathVariable("tno") Long tno, @RequestBody TodoDTO todoDTO) {
    // 경로 변수 tno와 요청 본문의 tno가 다를 경우를 방지하기 위해 DTO에 경로 변수 tno를 설정합니다.
    todoDTO.setTno(tno);
    todoService.modify(todoDTO);
    return Map.of("result", "success");
}


수정과 삭제 테스트
삭제 테스트는 현재 데이터베이스에 존재하는 번호를 
이용해서 테스트를 진행합니다(Access Token을 지정한 후에 테스트해야 합니다).


삭제가 제대로 되었는지는 데이터베이스를 통해서 확인합니다.




수정 작업은 JSON 문자열을 작성해서 전송해야 합니다.
/api/todo/{tno} modify

{
  "title": "수정테스트"
}


최종적으로 데이터베이스를 확인해 보면 다음과 같이 변경된 값들을 확인할 수 있습니다.



JWT? @PreAuthorize

JWT 기반의 인증 작업은 일반적인 세션 기반의 인증과 
다르기 때문에 스프링 시큐리티에서 사용하는 
@PreAuthorize를 이용할 수 없다는 단점이 있습니다. 

게다가 API 서버에서 CSRF 토큰을 사용하지 않는 경우가 많고,
CustomSecurityConfig 설정과 같이 세션을 생성 하지 않고, 
기존에 만들어진 세션을 사용하지도 않는 
SessionCreationPolicy.STATBLESS
설정하는 경우가 대부분입니다.

따라서 JWT 인증을 이용하는 때는 JWT 안에 
아이디(username, 예제에서는 mid)를 이용해서 인증 정보를 
직접 처리해서 스프링 시큐리티에서 활용할 수 있도록 
지정하는 방법을 생각할 수 있습니다.

스프링 시큐리티에서는 SecurityContextHolder라는 객체로 
인증과 관련된 정보를 저장해서 컨트롤러 등에서 이를 활용할 수 있는데 
이를 이용하면 @PreAuthorize를 이용할 수 있다 는 장점이 있습니다.



TokenCheckFilter 수정

JWT 토큰을 이용해서 인증 정보를 처리해야 하는 부분은 
TokenCheckFilter이므로 JWT에 대한 검증이 끝난 이후에 
인증 정보를 구성해서 이를 활용하도록 구성합니다.

TokenCheckFilter는 APIUserDetailsService를 이용해서 
JWT의 mid 값으로 사용자 정보를 얻어오도록 구성합니다.

@Log4j2
@RequiredArgsConstructor
public class TokenCheckFilter extends OncePerRequestFilter {
private final APIUserDetailsService apiUserDetailsService;
private final JWTUtil jwtutil；
...이하 생략...

TokenCheckFilter를 설정하는 CustomSecurityConfig의 설정 
역시 변경해 주어야 합니다

filterChain()에서는 TokenCheckFilter 생성 부분을 수정합니다.

// /api 경로에 대해 TokenCheckFilter 적용
http.addFilterBefore(
		tokenCheckFilter(jwtUtil, apiUserDetailsService),
		UsernamePasswordAuthenticationFilter.class
);

// RefreshTokenFilter를 TokenCheckFilter 이전에 등록
http.addFilterBefore(
		new RefreshTokenFilter("/refreshToken", jwtUtil),
		TokenCheckFilter.class
);


TokenCheckFilter를 생성하는 부분 역시 수정합니다.

private TokenCheckFilter tokenCheckFilter(JWTUtil jwtUtil, APIUserDetailsService apiUserDetailsService){
	return new TokenCheckFilter(apiUserDetailsService, jwtUtil);
}

Token CheckFilter 내부에는 JWT의 mid 값을 이용해서 
UserDetails를 구하고 이를 활용해서 
UsernamePasswordAuthenticationToken 객체를 구성합니다.

try {
    Map<String, Object> payload = validateAccessToken(request);
    // mid 추출
    String mid = (String) payload.get("mid");
    log.info("mid: " + mid);

    UserDetails userDetails = apiUserDetailsService.loadUserByUsername(mid);
    UsernamePasswordAuthenticationToken authentication = 
            new UsernamePasswordAuthenticationToken(
                    userDetails, 
                    null, 
                    userDetails.getAuthorities()
            );

    SecurityContextHolder.getContext().setAuthentication(authentication);
    filterChain.doFilter(request, response);
} catch (AccessTokenException accessTokenException) {
    accessTokenException.sendResponseError(response);
}




변경된 코드에서 가장 핵심적인 부분은 
UsernamePasswordAuthenticationToken 객체를 구성해서 
SecurityContextHolder.getContext().setAuthentication(authentication)를 
통해 스프링 시큐리티에서 사용할 수 있도록 하는 부분입니다.

@PreAuthorize 적용
변경된 TokenCheckFilter가 정상적으로 동작하는지 확인하기 위해서 
SampleController에 @PreAuthorize를 적용해 봅니다.

package org.zerock. api01. controller;
import io.swagger. annotations. ApiOperation;
import org. springframework. security. access.prepost.PreAuthorize; import org. springframework.web.bind.annotation.GetMapping; import org. springframework.web.bind.annotation. RequestMapping; import org. springframework. web.bind. annotation. RestController;
impont java.util.Arrays；
import java.util.List;


@RestController
@RequestMapping("/api/sample")
public class SampleController {

    @GetMapping("/doA")
    @PreAuthorize("hasRole('ROLE_USER')")
    public List<String> doA() {
        return Arrays.asList("AAA", "BBB", "C");
    }

    @GetMapping("/doB")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public List<String> doB() {
        return Arrays.asList("AdminAAA", "AdminBBB", "AdminCCC");
    }
}



JWT로 인증하는 사용자(APIUser)는 모두 'ROLE_USER' 
권한만을 가지고 있으므로 SampleController에 추가된 
api/sample/doB'를 호출할 때는 권한이 없으므로 
호출이 불가능하게 됩니다.

Access Token을 구하고 Swagger UI를 이용해서 
'api/sample/doA'와 api/sample/ doB를 확인해 봅니다.

'api/saumple/doA'의 경우 정상적으로 호출이 가능합니다.

'/api/sample/doB'의 경우 403 에러가 발생하게 됩니다.

JWT 인증과 @PreAuthorize를 이용하는 경우 
매번 호출할 때마다 APlUserDetailsService를 이용해서 
사용자 정보를 다시 로딩해야 하는 단점이 있습니다. 

이 과정에서 데이터베이스 호출 역시 피할 수 없습니다.

JWT를 이용하는 의미는 이미 적절한 토큰의 소유자가 
인증 완료되었다고 가정해야 하므로 가능하다면 
다시 인증 정보를 구성하는 것은 성능상 
좋은 방식은 아니라고 할 수 있습 니다.

